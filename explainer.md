# WebUSB Explained

## What is it?
Today when you connect a device to your computer you hope that somehow it will find the right driver and it will Just Work&trade;. For lots of devices it does because there are standardized drivers for things like keyboards, mice, hard drives and webcams built into the operating system. What about the long tail of unusual devices or the next generation of gadgets that haven't been standardized yet? WebUSB takes "plug and play" to the next level by connecting devices to the software that drives them across any platform by harnessing the power of web technologies.

## What is it not?
WebUSB does not attempt to provide a general mechanism for any web page to connect to any USB device. Historically USB hosts and devices have trusted each other too much to let arbitrary pages connect to them. There are published attacks against USB devices that will accept unsigned firmware updates that cause them to become malicious and attack the host they are connected to; exploiting the trust relationship in both directions.

Instead USB devices will be associated with a web origin and can only be connected to from a page from the same origin. New devices (or firmware updates) may include a list of acceptable origins that the user agent can query, similar to the CORS mechanism for HTTP requests. Device vendors may enable existing devices by registering them in an open directory mapping device IDs to acceptable origins.

## Appendix: A Brief Introduction to USB
USB is a network but it's very different from traditional TCP/IP networks. It is really more like an RPC system. All traffic is directed by the *host*, that is, your computer. Though some devices like smartphones can act as both a USB host and USB client they can only take on one role at a time.

### Descriptors
USB devices identify themselves to the host by providing a set of binary structures known as descriptors. The first one read by the host is the *device descriptor* which contains basic information such as the vendor and product IDs assigned by the USB-IF and the manufacturer. The host may then read the device's *configuration descriptor* which a description of the device's capabilities including the *interfaces* and *endpoints* it exposes. A class can be declared at the device level or for individual interfaces. A device with multiple interfaces providing different functions is known as a *composite device*.

### Transfers
Whether data is traveling from host to device or the other way around the transfer is always initiated by the host. *OUT* transfers carry data from host to device and may wait until the device acknowledges the data has been received. *IN* transfers carry data from device to host and may have to wait until the device has some data to send. Transfers are executed against one of a device's *endpoints* and there are different kinds depending on what type of traffic is being sent. *Bulk* transfers are good for sending lots of data with whatever bandwidth is available. This is what is used to read and write data to USB mass storage devices. *Interrupt* transfers offer guaranteed latency (by reserving bandwidth so that they can't be blocked by a large bulk transfers) but with limited packet sizes. These are used for signaling and for small packets like mouse movements and button presses. *Isochronous* transfers also reserve bandwidth but they don't guarantee delivery. They're used for streaming data like audio and video. Every device also has a special *control* endpoint. While regular endpoints only carry data in one direction or the other *control* transfers have a small header that is always sent to the device and contains request parameters in addition to a larger data payload that can be either IN or OUT.