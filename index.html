<!DOCTYPE html>
<html>
  <head>
    <title>WebUSB API</title>
    <meta charset="utf-8">
    <script src="https://www.w3.org/Tools/respec/respec-w3c-common"
            async class="remove"></script>
    <script class="remove">
      var respecConfig = {
        specStatus: "unofficial",
        shortName: "webusb-api",
        editors: [
          {
            name: "Reilly Grant",
            company: "Google",
            companyUrl: "https://www.google.com/"
          }, {
            name: "Ken Rockot",
            company: "Google",
            companyUrl: "https://www.google.com/"
          }
        ]
      };
    </script>
  </head>
  <body>
    <section id="abstract">
      <p>
        This document describes an API for direct access to Universal Serial Bus
        devices from web pages.
      </p>
    </section>

    <section id="sotd">
    </section>

    <section class="informative">
      <h2>Introduction</h2>
      <p>
        Today when you connect a device to your computer you hope that somehow
        it will find the right driver and it will Just Work&trade;. For lots of
        devices it does because there are standardized drivers for things like
        keyboards, mice, hard drives and webcams built into the operating
        system. What about the long tail of unusual devices or the next
        generation of gadgets that haven't been standardized yet? WebUSB takes
        "plug and play" to the next level by connecting devices to the software
        that drives them across any platform by harnessing the power of web
        technologies.
      </p>
      <p>
        WebUSB does not attempt to provide a general mechanism for any web page
        to connect to any USB device. Historically USB hosts and devices have
        trusted each other too much to let arbitrary pages connect to them.
        There are published attacks against USB devices that will accept
        unsigned firmware updates that cause them to become malicious and attack
        the host they are connected to; exploiting the trust relationship in
        both directions.
      </p>
      <p>
        Instead USB devices will be associated with a web origin and can only be
        connected to from a page from the same origin. New devices (or firmware
        updates) may include a list of acceptable origins that the user agent
        can query, similar to the CORS mechanism for HTTP requests. Device
        vendors may enable existing devices by registering them in an open
        directory which maps device IDs to acceptable origins.
      </p>
    </section>

    <section>
      <h2>Device Enumeration</h2>
      <pre class="idl">
        dictionary USBDeviceFilter {
          unsigned short vendorId;
          unsigned short productId;
          octet class;
          octet subclass;
          octet protocol;
        };

        dictionary USBDeviceEnumerationOptions {
          required sequence&lt;USBDeviceFilter> filters;
        };

        [NoInterfaceObject]
        interface USBDeviceEnumeration {
          Promise&lt;sequence&lt;USBDevice>> getDevices(USBDeviceEnumerationOptions options);
        };
      </pre>
      <p dfn-for="USBDeviceFilter">
        The <code><dfn>vendorId</dfn></code> and
        <code><dfn>productId</dfn></code> field will cause the filter to match
        any device with the given vendor and (optionally) product identifiers.
      </p>
      <p dfn-for="USBDeviceFilter">
        The <code><dfn>class</dfn></code>, <code><dfn>subclass</dfn></code> and
        <code><dfn>protocol</dfn></code> fields will cause the filter to match
        any device that implements the given class, class and subclass, or
        class, subclass and protocol tuple and any composite device with an
        interface implementing the same. A subclass MUST NOT be specified unless
        a class is provided and a protocol MUST NOT be specified unless a
        subclass is also provided.
      </p>
      <p dfn-for="USBDeviceEnumeration">
        The <code><dfn>getDevices</dfn>(<var>options</var>)</code> method, when
        invoked, MUST return a new promise <var>promise</var> and run the
        following steps in parallel:
      <p>
      <ol>
        <li>
          Enumerate all devices which individually match at least one of the
          filters in <code><var>options</var>.filters</code>.
          <p>
            The UA SHOULD apply additional origin-based filtering of available
            devices by consulting an authoritative list of device-origin
            mappings or referring to the origin list specified in the device's
            <dfn>Binary Object Store</dfn>
            (<abbr title="Binary Object Store">BOS</abbr>).
          </p>
          <p>
            The UA MAY provide additional mechanisms for blacklisting or
            whitelisting specific devices for arbitrary origins.
          </p>
          <p class="note" title="Binary Object Store">
            <span class="issue">TODO: More detail about this.</span>
          </p>
        </li>
        <li>
          Get the sequence of <a>USBDevice</a> objects representing all the
          devices which passed the filtering stage and resolve
          <var>promise</var> with the result.
        </li>
      </ol>
    </section>

    <section>
      <h2>Device Usage</h2>
      <pre class="idl">
        enum USBRequestType {
          "standard",
          "class",
          "vendor"
        };

        enum USBRecipient {
          "device",
          "interface",
          "endpoint",
          "other"
        };

        dictionary USBControlTransferParameters {
          required USBRequestType requestType;
          USBRecipient recipient;
          required octet request;
          required unsigned short value;
          unsigned short index;
        };

        [NoInterfaceObject]
        interface USBDevice {
          readonly attribute float usbVersion;
          readonly attribute octet deviceClass;
          readonly attribute octet deviceSubclass;
          readonly attribute octet deviceProtocol;
          readonly attribute unsigned short vendorId;
          readonly attribute unsigned short productId;
          readonly attribute float deviceVersion;
          readonly attribute DOMString? manufacturer;
          readonly attribute DOMString? product;
          readonly attribute DOMString? serialNumber;
          readonly attribute USBConfiguration[] configurations;
          Promise&lt;ArrayBuffer> controlTransferIn(USBControlTransferParameters parameters, unsigned short length);
          Promise&lt;void> controlTransferOut(USBControlTransferParameters parameters, optional ArrayBufferView data);
          Promise&lt;void> reset();
        };
      </pre>
      <p dfn-for="USBDevice">
        The <code><dfn>usbVersion</dfn></code> attribute declares the USB
        protocol version supported by the device. It SHALL correspond to the
        value of the <code>bcdUSB</code> field of the device descriptor.
      </p>
      <p dfn-for="USBDevice">
        The <code><dfn>deviceClass</dfn></code>,
        <code><dfn>deviceSubclass</dfn></code> and
        <code><dfn>deviceProtocol</dfn></code> attributes declare the
        communication interface supported by the device. They MUST correspond
        respectively to the values of the <code>bDeviceClass</code>,
        <code>bDeviceSubClass</code> and <code>bDeviceProtocol</code> fields of
        the device descriptor.
      </p>
      <p dfn-for="USBDevice">
        The <code><dfn>vendorId</dfn></code> and
        <code><dfn>productId</dfn></code> attribute declares the vendor ID
        of the device manufacturer and product ID assigned by the device
        manufacturer. They SHALL correspond to the values of the
        <code>idVendor</code> and <code>idProduct</code> fields of the device
        descriptor.
      </p>
      <p dfn-for="USBDevice">
        The <code><dfn>deviceVersion</dfn></code> attribute declares the
        device release number as defined by the device manufacturer. It SHALL
        correspond to the value of the <code>bcdDevice</code> field of the
        device descriptor.
      </p>
      <p dfn-for="USBDevice">
        The <code><dfn>configurations</dfn></code> attribute contains a list of
        configurations supported by the device. These configurations SHALL be
        populated from the configuration descriptors reported by the device and
        the number of elements in this list SHALL match the value of the
        <code>bNumConfigurations</code> field of the device descriptor.
      </p>
      <p dfn-for="USBDevice">
        The <code><dfn>manufacturer</dfn></code>,
        <code><dfn>product</dfn></code> and <code><dfn>serialNumber</dfn></code>
        attributes SHOULD contain the values of the string descriptors
        referenced by the <code>iManufacturer</code>, <code>iProduct</code> and
        <code>iSerialNumber</code> fields of the device descriptor if each is
        available.
      </p>
      <p dfn-for="USBDevice">
        The <code><dfn>controlTransferIn</dfn>(<var>parameters</var>,
        <var>length</var>)</code> method issues a control transfer to the device
        through its default endpoint. If non-zero,
        <code><var>length</var></code> bytes of data will be read from the
        device during the <code>IN</code> phase of the transaction.
      </p>
      <p dfn-for="USBDevice">
        The <code><dfn>controlTransferOut</dfn>(<var>parameters</var>,
        <var>data</var>)</code> method issues a control transfer to the device
        through its default endpoint. If provided, the contents of the
        <code><var>data</var></code> buffer will be sent to the device during
        the OUT phase of the transaction. The <code>wLength</code> field of the
        <code>SETUP</code> packet will be populated with the length of this
        buffer.
      </p>
      <p dfn-for="USBDevice">
        The <code><dfn>reset</dfn>()</code> method performs a soft reset on the
        device.
      </p>
      <p class="issue">
        Concepts like transaction phases, packet contents, and device reset
        should be discussed in some additional detail with references to the
        USB spec.
      </p>
    </section>

    <section>
      <h2>Device Configurations</h2>
      <pre class="idl">
        [NoInterfaceObject]
        interface USBConfiguration {
          readonly attribute octet configurationValue;
          readonly attribute DOMString? configuration;
          readonly attribute USBInterface[] interfaces;
          Promise&lt;void> select();
        };
      </pre>
      <p dfn-for="USBConfiguration">
        The <code><dfn>configuration</dfn></code> attribute SHOULD contain the
        value of the string descriptor referenced by the
        <code>iConfiguration</code> field of the configuration descriptor, if
        available.
      </p>
      <p dfn-for="USBConfiguration">
        <code><dfn>select</dfn>()</code> issues an appropriate SET_CONFIGURATION
        control request to set this configuration as the device's current
        configuration. The operating system MAY automatically select the first
        available device configuration.
      </p>
      <p class="issue">
        Document configurationValue.
      </p>
      <p class="issue">
        Include some non-normative information about device configurations
      </p>
    </section>

    <section>
      <h2>Device Interfaces</h2>
      <pre class="idl">
        [NoInterfaceObject]
        interface USBInterface {
          readonly attribute octet interfaceNumber;
          readonly attribute USBAlternateInterface[] alternates;
          Promise&lt;void> claim();
          Promise&lt;void> release();
          Promise&lt;ArrayBuffer> controlTransferIn(USBControlTransferParameters parameters, unsigned short length);
          Promise&lt;void> controlTransferOut(USBControlTransferParameters parameters, optional ArrayBufferView data);
        };

        [NoInterfaceObject]
        interface USBAlternateInterface {
          readonly attribute octet alternateSetting;
          readonly attribute octet interfaceClass;
          readonly attribute octet interfaceSubclass;
          readonly attribute octet interfaceProtocol;
          readonly attribute DOMString? interface;
          readonly attribute USBEndpoint[] endpoints;
          Promise&lt;void> select();
        };
      </pre>
      <p dfn-for="USBInterface">
        The <code><dfn>claim</dfn>()</code> method requests that control over
        the interface be granted to the UA.
      </p>
      <p dfn-for="USBInterface">
        The <code><dfn>release</dfn>()</code> method releases the UA's control
        over the interface if previously granted.
      </p>
      <p dfn-for="USBAlternateInterface">
        Each alternative interface configuration SHALL have a unique
        <code><dfn>alternateSetting</dfn></code> value that matches the
        <code>bAlternateSetting</code> field of the interface descriptor that
        defines it.
      </p>
      <p dfn-for="USBAlternateInterface">
        The <code><dfn>interfaceClass</dfn></code>,
        <code><dfn>interfaceSubclass</dfn></code> and
        <code><dfn>interfaceProtocol</dfn></code> attributes declare the
        communication interface supported by the interface. They MUST correspond
        respectively to the values of the <code>bInterfaceClass</code>,
        <code>bInterfaceSubClass</code> and <code>bInterfaceProtocol</code>
        fields of the interface descriptor.
      </p>
      <p dfn-for="USBAlternateInterface">
        The <code><dfn>interface</dfn></code> attribute SHOULD contain the
        value of the string descriptor referenced by the
        <code>iInterface</code> field of the interface descriptor, if available.
      </p>
      <p dfn-for="USBAlternateInterface">
        The <code><dfn>select</dfn>()</code> method issues the appropriate<code>
        SET_INTERFACE</code> request to select this alternate interface. By
        default the alternate interface with <code>alternateSetting</code> set
        to <code>0</code> is selected.
      </p>
    </section>

    <section>
      <h2>Data Transfer Endpoints</h2>
      <pre class="idl">
        enum USBDirection {
          "in",
          "out"
        };

        enum USBEndpointType {
          "bulk",
          "interrupt",
          "isochronous"
        };

        [NoInterfaceObject]
        interface USBEndpoint {
          readonly attribute octet endpointNumber;
          readonly attribute USBDirection direction;
          readonly attribute USBEndpointType type;
          Promise&lt;ArrayBuffer> controlTransferIn(USBControlTransferParameters parameters, unsigned short length);
          Promise&lt;void> controlTransferOut(USBControlTransferParameters parameters, optional ArrayBufferView data);
        };

        [NoInterfaceObject]
        interface USBBulkEndpoint : USBEndpoint {
          Promise&lt;void> clearHalt();
          Promise&lt;ArrayBuffer> transferIn(unsigned long length);
          Promise&lt;unsigned long> transferOut(ArrayBufferView data);
        };

        [NoInterfaceObject]
        interface USBInterruptEndpoint : USBEndpoint {
          Promise&lt;void> clearHalt();
          Promise&lt;ArrayBuffer> transferIn(unsigned long length);
          Promise&lt;unsigned long> transferOut(ArrayBufferView data);
        };

        [NoInterfaceObject]
        interface USBIsochronousEndpoint : USBEndpoint {
          Promise&lt;ArrayBuffer[]> transferIn(unsigned long[] packetLengths);
          Promise&lt;unsigned long[]> transferOut(ArrayBufferView[] packets);
        };
      </pre>
      <p class="issue">
        This section appears to be missing lots of useful text!
      </p>
    </section>
  </body>
</html>
