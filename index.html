<!DOCTYPE html>
<html>
  <head>
    <title>WebUSB API</title>
    <meta charset='utf-8'>
    <script src='http://www.w3.org/Tools/respec/respec-w3c-common'
            async class='remove'></script>
    <script class='remove'>
      var respecConfig = {
        specStatus: "unofficial",
        shortName: "webusb-api",
        editors: [
          {
            name: "Reilly Grant",
            company: "Google",
            companyUrl: "https://www.google.com/"
          }, {
            name: "Ken Rockot",
            company: "Google",
            companyUrl: "https://www.google.com/"
          }
        ]
      };
    </script>
  </head>
  <body>
    <section id='abstract'>
      <p>
        This document describes an API for direct access to Universal Serial Bus
        devices from web pages.
      </p>
    </section>

    <section id='sotd'>
    </section>

    <section class='informative'>
      <h2>Introduction</h2>
      <p>
        Today when you connect a device to your computer you hope that somehow
        it will find the right driver and it will Just Work&trade;. For lots of
        devices it does because there are standardized drivers for things like
        keyboards, mice, hard drives and webcams built into the operating
        system. What about the long tail of unusual devices or the next
        generation of gadgets that haven't been standardized yet? WebUSB takes
        "plug and play" to the next level by connecting devices to the software
        that drives them across any platform by harnessing the power of web
        technologies.
      </p>
      <p>
        WebUSB does not attempt to provide a general mechanism for any web page
        to connect to any USB device. Historically USB hosts and devices have
        trusted each other too much to let arbitrary pages connect to them.
        There are published attacks against USB devices that will accept
        unsigned firmware updates that cause them to become malicious and attack
        the host they are connected to; exploiting the trust relationship in
        both directions.
      </p>
      <p>
        Instead USB devices will be associated with a web origin and can only be
        connected to from a page from the same origin. New devices (or firmware
        updates) may include a list of acceptable origins that the user agent
        can query, similar to the CORS mechanism for HTTP requests. Device
        vendors may enable existing devices by registering them in an open
        directory which maps device IDs to acceptable origins.
      </p>
    </section>

    <section>
      <h2>Device Enumeration</h2>
      <pre class="idl">
        dictionary USBDeviceFilter {
          unsigned short vendorId;
          unsigned short productId;
          octet interfaceClass;
          octet interfaceSubclass;
          octet interfaceProtocol;
        };

        dictionary USBDeviceEnumerationOptions {
          required sequence&lt;USBDeviceFilter> filters;
        };

        [NoInterfaceObject]
        interface USBDeviceEnumeration {
          Promise&lt;sequence&lt;USBDevice>> getDevices(USBDeviceEnumerationOptions options);
        };
      </pre>
      <p dfn-for="USBDeviceEnumeration">
        The <code><dfn>getDevices</dfn>(<var>options</var>)</code> method, when
        invoked, MUST return a new promise <var>promise</var> and run the
        following steps in parallel:
      <p>
      <ol>
        <li>
          Enumerate all devices which individually match at least one of the
          filters in <code><var>options</var>.filters</code>.
          <p>
            The UA SHOULD apply additional origin-based filtering of available
            devices by consulting an authoritative list of device-origin
            mappings or referring to the origin list specified in the device's
            <dfn>Binary Object Store</dfn>
            (<abbr title="Binary Object Store">BOS</abbr>).
          </p>
          <p>
            The UA MAY provide additional mechanisms for blacklisting or
            whitelisting specific devices for arbitrary origins.
          </p>
          <p class="note" title="USBDeviceFilter members">
          </p>
          <p class="note" title="Binary Object Store">
            <span class="issue">TODO: More detail about this.</span>
          </p>
        </li>
        <li>
          Get the sequence of <a>USBDevice</a> objects representing all the
          devices which passed the filtering stage and resolve
          <var>promise</var> with the result.
        </li>
      </ol>
    </section>

    <section>
      <h2>Data Transfer</h2>
      <p>
        <dl title='enum UsbDirection' class='idl'>
          <dt>in</dt>
          <dd>Data is transmitted from the USB device to the USB host.</dd>
          <dt>out</dt>
          <dd>Data is transmitted from the USB host to the USB device.</dd>
        </dl>
      </p>
      <p>
        <dl title='enum UsbRequestType' class='idl'>
          <dt>standard</dt>
          <dd></dd>
          <dt>class</dt>
          <dd></dd>
          <dt>vendor</dt>
          <dd></dd>
        </dl>
      </p>
      <p>
        <dl title='enum UsbRecipient' class='idl'>
          <dt>device</dt>
          <dd></dd>
          <dt>interface</dt>
          <dd></dd>
          <dt>endpoint</dt>
          <dd></dd>
          <dt>other</dt>
          <dd></dd>
          <dt>vendor</dt>
          <dd></dd>
        </dl>
      </p>

      <section>
        <h2>Devices</h2>
        <p>
          <dl title='interface UsbDevice' class='idl'>
            <dt>readonly attribute unsigned short vendorId</dt>
            <dd></dd>
            <dt>readonly attribute unsigned short productId</dt>
            <dd></dd>
            <dt>readonly attribute UsbConfiguration[] configurations</dt>
            <dd></dd>
            <dt>Promise&lt;ArrayBuffer&gt; controlTransferIn(UsbRequestType requestType, UsbRecipient recipient, octet request, unsigned short value, unsigned short index, unsigned short length)</dt>
            <dd>Issues a control transfer to the device through its default endpoint. <a>length</a> bytes of data will be read from the device during the IN phase of the transaction.</dd>
            <dt>Promise&lt;void&gt; controlTransferOut(UsbRequestType requestType, UsbRecipient recipient, octet request, unsigned short value, unsigned short index, optional ArrayBuffer data)</dt>
            <dd>Issues a control transfer to the device through its default endpoint. The given buffer will be sent to the device during the OUT phase of the transaction. The wLength field of the SETUP packet will be populated with the length of this buffer.</dd>
            <dt>Promise&lt;void&gt; reset()</dt>
            <dd>Performs a complete reset of the device.</dd>
          </dl>
        </p>
      </section>

      <section>
        <h2>Configurations</h2>
        <p>
          <dl title='interface UsbConfiguration' class='idl'>
            <dt>readonly attribute octet configurationValue</dt>
            <dd></dd>
            <dt>readonly attribute UsbInterface[] interfaces</dt>
            <dd></dd>
            <dt>Promise&lt;void&gt; select()</dt>
            <dd>Issues the appropriate SET_CONFIGURATION request to select this configuration.</dd>
          </dl>
        </p>
      </section>

      <section>
        <h2>Interfaces</h2>
        <p>
          <dl title='interface UsbInterface' class='idl'>
            <dt>readonly attribute octet interfaceNumber</dt>
            <dd></dd>
            <dt>readonly attribute octet alternateSetting</dt>
            <dd></dd>
            <dt>readonly attribute UsbEndpoint[] endpoints</dt>
            <dd></dd>
            <dt>Promise&lt;void&gt; claim()</dt>
            <dd>Requests control over this interface be granted to the user agent.</dd>
            <dt>Promise&lt;void&gt; release()</dt>
            <dd>Releases control over this interface from the user agent.</dt>
            <dt>Promise&lt;void&gt; select()</dt>
            <dd>Issues the appropriate SET_INTERFACE request to select this alternate interface.</dd>
          </dl>
        </p>
      </section>

      <section>
        <h2>Endpoints</h2>
        <p>
          <dl title='interface UsbEndpoint' class='idl'>
            <dt>readonly attribute octet endpointNumber</dt>
            <dd></dd>
            <dt>readonly attribute UsbDirection direction</dt>
            <dd></dd>
          </dl>
        </p>
      </section>

      <section>
        <h2>Bulk and Interrupt Endpoints</h2>
        <p>
          <dl title='interface UsbBulkInterruptEndpoint : UsbEndpoint' class='idl'>
            <dt>Promise&lt;void&gt; clearHalt()</dt>
            <dd></dd>
            <dt>Promise&lt;ArrayBuffer&gt; transferIn(unsigned long length)</dt>
            <dd></dd>
            <dt>Promise&lt;unsigned long&gt; transferOut(ArrayBuffer buffer)</dt>
            <dd></dd>
          </dl>
        </p>
      </section>

      <section>
        <h2>Isochronous Endpoints</h2>
        <p>
          <dl title='interface UsbIsochronousEndpoint : UsbEndpoint' class='idl'>
            <dt>Promise&lt;ArrayBuffer[]&gt; transferIn(unsigned long[] packetLengths)</dt>
            <dd></dd>
            <dt>Promise&lt;unsigned long[]&gt; transferOut(ArrayBuffer[] packets)</dt>
            <dd></dd>
          </dl>
        </p>
      </section>
    </section>
  </body>
</html>
