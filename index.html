<!DOCTYPE html>
<html>
  <head>
    <title>WebUSB API</title>
    <meta charset="utf-8">
    <script src="https://www.w3.org/Tools/respec/respec-w3c-common"
            async class="remove"></script>
    <script class="remove">
      var respecConfig = {
        specStatus: "unofficial",
        shortName: "webusb-api",
        editors: [
          {
            name: "Reilly Grant",
            company: "Google",
            companyUrl: "https://www.google.com/"
          }, {
            name: "Ken Rockot",
            company: "Google",
            companyUrl: "https://www.google.com/"
          }
        ],

        localBiblio: {
          "USB31": {
            href: "http://www.usb.org/developers/docs/usb_31_060115.zip",
            title: "Universal Serial Bus 3.1 Specification",
            publisher: "USB Implementors Forum",
            date: "26 July 2013",
          }
        }
      };
    </script>
    <style>
      table {
        border-collapse: collapse;
        border-left-style: hidden;
        border-right-style: hidden;
        text-align: left;
      }
      table caption {
        font-weight: bold;
        padding: 3px;
        text-align: left;
      }
      table td, table th {
        border: 1px solid black;
        padding: 3px;
      }
    </style>
  </head>
  <body>
    <section id="abstract">
      <p>
        This document describes an API for direct access to Universal Serial Bus
        devices from web pages.
      </p>
    </section>

    <section id="sotd">
    </section>

    <section class="informative">
      <h2>Introduction</h2>
      <p>
        The Universal Serial Bus (USB) is the de-facto standard for wired
        peripherals. Most USB devices implement one of roughly a dozen standard
        "device classes" which specify a way for the device to advertize the
        features it supports and commands and data formats for using those
        features. Standard device classes include keyboard, mice, audio, video
        and storage devices. Operating systems support such devices using the
        "class driver" provided by the OS vendor. There is however a long tail
        of devices that do not fit into one of the standardized device classes.
        These devices require hardware vendors to write native drivers and SDKs
        in order for developers to take advantage of them and this native code
        prevents these devices from being used by the web.
      </p>
      <p>
        The WebUSB API provides a way to safely expose USB device services to
        the web. It provides an API familiar to developers who have used
        existing native USB libraries and exposes the device interfaces defined
        by existing specifications. With this API hardware manufacturers will
        have the ability to build cross-platform JavaScript SDKs for their
        devices. This will be good for the web because, instead of waiting for a
        new kind of device to be popular enough for browsers to provide a
        specific API, new and innovative hardware can be built for the web from
        day one.
      </p>
    </section>

    <section>
      <h2>Security and Privacy Considerations</h2>
      <p>
        USB hosts and devices historically trust each other. There are published
        attacks against USB devices that will accept unsigned firmware updates.
        These vulnerabilities permit an attacker to gain a foothold in the
        device and attack the original host or any other host to which they are
        later connected. For this reason WebUSB does not attempt to provide a
        mechanism for any web page to connect to arbitrary devices.
      </p>
      <p>
        Direct access to peripherals also poses a privacy risk. Knowing the make
        and model of connected devices provides additional bits of entropy for
        fingerprinting. If devices also posess some form of serial number then
        they can be uniquely identifying. Additionally a device may have access
        to data about its environment or directly store user data.
      </p>
      <p>
        For this reason this specification outlines to mechanisms that can be
        combined by the UA before a site is granted access to a device. First,
        so that the device can protect itself from malicious sites it can
        provide a set of origins that are allowed to connect to it. These are
        similar to the [[CORS]] mechanism and can conceptually be thought of as
        treating USB devices as their own origins in the "usb" scheme.
        For devices manufacturered before this specificiation is adopted
        information about allowed origins and landing pages can also be provided
        out of band by being published in a public registry. Second, so that the
        user's privacy is protected the UA may prompt the user for authorization
        to allow a site to detect the presense of a device and connect to it.
      </p>
      <p>
        To help ensure that only the entity the user approved for access
        actually has access, this specification requires that only secure
        contexts as described in [[powerful-features]] can access USB devices.
      </p>
    </section>

    <section>
      <h2>WebUSB Descriptors and Requests</h2>
      <p>
        This specification defines descriptors and commands the UA MAY use to
        gather information about the device specific to implementing this API.
      </p>

      <section>
        <h3><dfn>WebUSB Platform Capability Descriptor</dfn></h3>
        <p>
          A device announces support for the WebUSB command set by including the
          following <a>Platform Descriptor</a> in its <a>Binary Object
          Store</a>:
        </p>

        <table>
          <tr>
            <th>Offset</th>
            <th>Field</th>
            <th>Size</th>
            <th>Value</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>0</td>
            <td>bLength</td>
            <td>1</td>
            <td>Number</td>
            <td>Size of this descriptor. Must be set to 23.</td>
          </tr>
          <tr>
            <td>1</td>
            <td>bDescriptorType</td>
            <td>1</td>
            <td>Constant</td>
            <td>DEVICE CAPABILITY descriptor type ([[USB31]] Table 9-6).</td>
          </tr>
          <tr>
            <td>2</td>
            <td>bDevCapabilityType</td>
            <td>1</td>
            <td>Constant</td>
            <td>PLATFORM capability type ([[USB31]] Table 9-14).</td>
          </tr>
          <tr>
            <td>3</td>
            <td>bReserved</td>
            <td>1</td>
            <td>Number</td>
            <td>This field is reserved and shall be set to zero.</td>
          </tr>
          <tr>
            <td>4</td>
            <td>PlatformCapabilityUUID</td>
            <td>16</td>
            <td>UUID</td>
            <td>Must be set to {3408b638-09a9-47a0-8bfd-a0768815b665}.</td>
          </tr>
          <tr>
            <td>20</td>
            <td>bcdVersion</td>
            <td>2</td>
            <td>BCD</td>
            <td>Protocol version supported. Must be set to 0x0100.</td>
          </tr>
          <tr>
            <td>22</td>
            <td>bVendorCode</td>
            <td>1</td>
            <td>Number</td>
            <td>bRequest value used for issuing WebUSB requests.</td>
          </tr>
        </table>
      </section>

      <section>
        <h3>WebUSB Device Requests</h3>
        <p>
          All control transfers defined by this specification are considered to
          be vendor-specific requests. The <code>bVendorCode</code> value found
          in the <a>WebUSB Platform Capability Descriptor</a> provides the UA
          with the <code>bRequest</code> the device expects the host to use when
          issuing control transfers these requests. The request type is then
          specified in the <code>wIndex</code> field.
        </p>

        <table>
          <caption>WebUSB Request Codes</caption>
          <tr>
            <th>Constant</th>
            <th>Value</th>
          </tr>
          <tr>
            <td>GET_ALLOWED_ORIGINS</td>
            <td>1</td>
          </tr>
          <tr>
            <td>GET_LANDING_PAGE</td>
            <td>2</td>
          </tr>
        </table>

        <section>
          <h4><dfn>Get Allowed Origins</dfn></h4>
          <p>
            This request gets the set of origins allowed to access the device.
            It is analogous to the <code>Access-Control-Allow-Origin</code>
            header defined by [[CORS]].
          </p>

          <p>
            The device MUST respond with data beginning with a <a>Descriptor Set
            Header</a> or stall the transfer.
          </p>

          <p>
            The URLs returned by this request MUST be interpreted as origins (as
            defined by [[RFC6454]]) and so content beyond the scheme/host/port
            triple MUST be ignored.
          </p>

          <p>
            If the UA chooses to enforce this policy then an origin <dfn>is
            allowed to access a device</dfn> if there exists a <a>URL
            descriptor</a> request matching that origin is in the top-level
            <a>Descriptor Set Header</a> or any descriptors below it. An origin
            <dfn data-lt="is allowed to access configuration">is allowed to
            access a configuration</dfn> if a <a>URL descriptor</a> matching
            that origin is within a matching <a>Configuration Subset Header</a>
            or within the top-level <a>Descriptor Set Header</a>. An origin
            <dfn data-lt="is allowed to access interface">is allowed to access
            an interface</dfn> if there is a <a>URL descriptor</a> matching that
            origin within a matching <a>Function Subset Header</a>, the
            <a>Configuration Subset Header</a> containing it or the top-level
            <a>Descriptor Set Header</a>.
          </p>
          <table>
            <tr>
              <th>bmRequestType</td>
              <th>bRequest</th>
              <th>wValue</th>
              <th>wIndex</th>
              <th>wLength</th>
              <th>Data</th>
            </tr>
            <tr>
              <td>11000000B</td>
              <td><code>bVendorCode</code></td>
              <td>Zero</td>
              <td>GET_ALLOWED_ORIGINS</td>
              <td>Descriptor Length</td>
              <td>Descriptor</td>
            </tr>
          </table>
        </section>

        <section>
          <h4>Get Landing Page</h4>
          <p>
            This request gets the landing page to which the UA can be navigated
            in order to interact with the device.
          </p>

          <p>
            The device MUST respond with a single <a>URL Descriptor</a> or stall
            the transfer.
          </p>

          <table>
            <tr>
              <th>bmRequestType</td>
              <th>bRequest</th>
              <th>wValue</th>
              <th>wIndex</th>
              <th>wLength</th>
              <th>Data</th>
            </tr>
            <tr>
              <td>11000000B</td>
              <td><code>bVendorCode</code></td>
              <td>Zero</td>
              <td>GET_LANDING_PAGE</td>
              <td>Descriptor Length</td>
              <td>Descriptor</td>
            </tr>
          </table>
        </section>
      </section>

      <section>
        <h3>WebUSB Descriptors</h3>
        <p>
          These descriptor types are returned by requests defined in this
          specification.
        </p>

        <table>
          <caption>WebUSB Descriptor Types</caption>
          <tr>
            <th>Constant</th>
            <th>Value</th>
          </tr>
          <tr>
            <td>WEBUSB_DESCRIPTOR_SET_HEADER</td>
            <td>0</td>
          </tr>
          <tr>
            <td>WEBUSB_CONFIGURATION_SUBSET_HEADER</td>
            <td>1</td>
          </tr>
          <tr>
            <td>WEBUSB_FUNCTION_SUBSET_HEADER</td>
            <td>2</td>
          </tr>
          <tr>
            <td>WEBUSB_URL</td>
            <td>3</td>
          </tr>
        </table>

        <section>
          <h4><dfn>Descriptor Set Header</dfn></h4>
          <p>
            This descriptor defines the length of the set of descriptors that
            will follow it. If a device response begins with this descriptor the
            <code>wLength</code> value indicates the host has a large enough
            buffer to receive it the device MUST respond with exactly
            <code>wTotalLength</code> bytes of data. The entire content of this
            response MUST consist of valid descriptors. There MUST NOT be unused
            bytes at the end.
          </p>

          <table>
            <tr>
              <th>Offset</th>
              <th>Field</th>
              <th>Size</th>
              <th>Value</th>
              <th>Description</th>
            </tr>
            <tr>
              <td>0</td>
              <td>bLength</td>
              <td>1</td>
              <td>Number</td>
              <td>Size of this descriptor. Must be set to 4.</td>
            </tr>
            <tr>
              <td>1</td>
              <td>bDescriptorType</td>
              <td>1</td>
              <td>Constant</td>
              <td>WEBUSB_DESCRIPTOR_SET_HEADER.</td>
            </tr>
            <tr>
              <td>2</td>
              <td>wTotalLength</td>
              <td>2</td>
              <td>Number</td>
              <td>Total size of this and all following descriptors.</td>
            </tr>
          </table>
        </section>

        <section>
          <h4><dfn data-lt="configuration subset header|configuration subset headers">Configuration Subset Header</dfn></h4>
          <p>
            This header declares that the descriptors following it (up to
            <code>wTotalLength</code> bytes) relate to the USB device
            configuration described by the <a>configuration descriptor</a>
            with the given <code>bConfigurationValue</code>.
          </p>
          <p>
            This descriptor MUST be contained within a <a>Descriptor Set
            Header</a>.
          </p>
          <table>
            <tr>
              <th>Offset</th>
              <th>Field</th>
              <th>Size</th>
              <th>Value</th>
              <th>Description</th>
            </tr>
            <tr>
              <td>0</td>
              <td>bLength</td>
              <td>1</td>
              <td>Number</td>
              <td>Size of this descriptor. Must be set to 5.</td>
            </tr>
            <tr>
              <td>1</td>
              <td>bDescriptorType</td>
              <td>1</td>
              <td>Constant</td>
              <td>WEBUSB_CONFIGURATION_SUBSET_HEADER.</td>
            </tr>
            <tr>
              <td>2</td>
              <td>bConfigurationValue</td>
              <td>1</td>
              <td>Number</td>
              <td>Configuration to which this section applies.</td>
            </tr>
            <tr>
              <td>3</td>
              <td>wTotalLength</td>
              <td>2</td>
              <td>Number</td>
              <td>
                Total size of this and the following descriptors to which this
                header applies.
              </td>
            </tr>
          </table>
        </section>

        <section>
          <h4><dfn data-lt="function subset header|function subset headers">Function Subset Header</dfn></h4>
          <p>
            This header declares that the descriptors following it (up to
            <code>wTotalLength</code> bytes) relate to the USB device interface
            described by the <a>interface descriptor</a> with a
            <code>bInterfaceNumber</code> equal to
            <code>bFirstInterfaceNumber</code> or the set of interfaces defined
            as a function by an <a>interface association descriptor</a> with an
            equal <code>bFirstInterfaceNumber</code>.
          </p>
          <p>
            This descriptor MUST be contained within a <a>Configuration Subset
            Header</a>.
          </p>
          <table>
            <caption>WebUSB Function Subset Header</caption>
            <tr>
              <th>Offset</th>
              <th>Field</th>
              <th>Size</th>
              <th>Value</th>
              <th>Description</th>
            </tr>
            <tr>
              <td>0</td>
              <td>bLength</td>
              <td>1</td>
              <td>Number</td>
              <td>Size of this descriptor. Must be set to 5.</td>
            </tr>
            <tr>
              <td>1</td>
              <td>bDescriptorType</td>
              <td>1</td>
              <td>Constant</td>
              <td>WEBUSB_FUNCTION_SUBSET_HEADER.</td>
            </tr>
            <tr>
              <td>2</td>
              <td>bFirstInterfaceNumber</td>
              <td>1</td>
              <td>Number</td>
              <td>
                First interface of the function to which this section applies.
              </td>
            </tr>
            <tr>
              <td>3</td>
              <td>wTotalLength</td>
              <td>2</td>
              <td>Number</td>
              <td>
                Total size of this and the following descriptors to which this
                header applies.
              </td>
            </tr>
          </table>
        </section>

        <section>
          <h4><dfn data-lt="URL Descriptor|URL Descriptors">URL Descriptor</dfn></h4>
          <p>
            This descriptor contains a single URL. It may be contained within a
            <a>Descriptor Set Header</a> to apply to the entire device, a
            <a>Configuration Subset Header</a> to apply to a specific
            configuration, or a <a>Function Subset Header</a> to apply to the
            set of interfaces comprising that function.
          </p>

          <table>
            <tr>
              <th>Offset</th>
              <th>Field</th>
              <th>Size</th>
              <th>Value</th>
              <th>Description</th>
            </tr>
            <tr>
              <td>0</td>
              <td>bLength</td>
              <td>1</td>
              <td>Number</td>
              <td>Size of this descriptor.</td>
            </tr>
            <tr>
              <td>1</td>
              <td>bDescriptorType</td>
              <td>1</td>
              <td>Constant</td>
              <td>WEBUSB_URL.</td>
            </tr>
            <tr>
              <td>2</td>
              <td>URL</td>
              <td>Variable</td>
              <td>String</td>
              <td>UTF-8 encoded URL.</td>
            </tr>
          </table>
        </section>
      </section>

      <section>
        <h3>Public Device Registry</h3>
        <p>
          The <a>WebUSB Platform Capability Descriptor</a> and descriptors
          returned by the requests defined above can be elided by publishing
          this information in a public registry of supported USB devices. This
          will allow device manufacturers to support WebUSB on existing devices.
        </p>
      </section>
    </section>

    <section>
      <h2>Device Enumeration</h2>
      <pre class="idl">
        dictionary USBDeviceFilter {
          unsigned short vendorId;
          unsigned short productId;
          octet classCode;
          octet subclassCode;
          octet protocolCode;
        };

        dictionary USBDeviceRequestOptions {
          required sequence&lt;USBDeviceFilter> filters;
        };

        [NoInterfaceObject]
        interface USB {
          attribute EventHandler onconnect;
          attribute EventHandler ondisconnect;
          Promise&lt;sequence&lt;USBDevice>> getDevices();
          Promise&lt;USBDevice> requestDevice(USBDeviceRequestOptions options);
        };
        USB implements EventTarget;

        partial interface Navigator {
          readonly attribute USB usb;
        };
      </pre>
      <p dfn-for="USBDeviceFilter">
        The <code><dfn>vendorId</dfn></code> and
        <code><dfn>productId</dfn></code> field will cause the filter to match
        any device with the given vendor and (optionally) product identifiers.
      </p>
      <p dfn-for="USBDeviceFilter">
        The <code><dfn>classCode</dfn></code>,
        <code><dfn>subclassCode</dfn></code> and
        <code><dfn>protocolCode</dfn></code> fields will cause the filter to
        match any device that implements the given class, class and subclass, or
        class, subclass and protocol tuple and any composite device with an
        interface implementing the same. A subclass MUST NOT be specified unless
        a class is provided and a protocol MUST NOT be specified unless a
        subclass is also provided.
      </p>
      <p>
        The UA MUST be able to <dfn>enumerate all devices attached to the
        system</dfn>. It is, however NOT required to perform this work each time
        an algorithm requests an enumeration. The UA MAY cache the result of the
        first enumeration it performs and then begin monitoring for device
        connection and disconnection events, adding connected devices to its
        cached enumeration and removing disconnected devices. This mode of
        operation is preferred as it reduces the number of operating system
        calls made and amount of bus traffic generated by the
        <code><a data-lt="USB.getDevices">getDevices</a>()</code> and
        <code><a data-lt="USB.requestDevice">requestDevice</a>()</code> methods.
      </p>
      <p>
        The UA MUST maintain an <dfn>allowed devices set</dfn> for each script
        execution environment. Once a device is added to this set it SHALL
        remain in the set for a period of time determined by the UA's ability to
        identify the device.
      </p>
      <ul>
        <li>
          For a device with a unique identifier such as a serial number or
          container ID the device SHALL remain in the <a>allowed devices set</a>
          until explicitly removed by the user. Vendor and product IDs MUST NOT
          be considered uniquely identifying.
        </li>
        <li>
          For a device without a unique identifier the device SHALL remain in
          the <a>allowed devices set</a> until it becomes uncertain whether the
          device connected to the host is still the device originally added to
          the set. This MAY happen when the device is disconnected from the
          host, when the UA exits or, if tracked by the host operating system,
          when the host is shut down.
        </li>
      </ul>
      <p dfn-for="USB">
        The <dfn>onconnect</dfn> attribute is an Event handler IDL attribute for
        the <a>connect</a> event type.
      </p>
      <p dfn-for="USB">
        The <dfn>ondisconnect</dfn> attribute is an Event handler IDL attribute
        for the <a>disconnect</a> event type.
      </p>
      <p dfn-for="USB">
        The <code><dfn>getDevices</dfn>()</code> method, when
        invoked, MUST return a new promise and run the following steps in
        parallel:
      </p>
      <ol>
        <li>
          If the incumbent settings object is not a secure context, reject
          <var>promise</var> with a <code>SecurityError</code> and abort these
          steps.
        </li>
        <li>
          <a>Enumerate all devices attached to the system</a>. Let this result
          be <var>enumerationResult</var>.
        </li>
        <li>
          Remove all devices from <var>enumerationResult</var> that are not in
          the current script execution environment's <a>allowed devices set</a>.
        </li>
        <li>
          For each remaining <var>device</var> in <var>enumerationResult</var>
          get the <a>USBDevice</a> object representing <var>device</var>, and
          add the result to <var>devices</var>.
        </li>
        <li>
          Resolve <var>promise</var> with <var>devices</var>.
        </li>
      </ol>
      <p dfn-for="USB">
        The <code><dfn>requestDevice</dfn>(<var>options</var>)</code> method,
        when invoked, MUST return a new promise <var>promise</var> and run the
        following steps in parallel:
      </p>
      <ol>
        <li>
          If the incumbent settings object is not a secure context, reject
          <var>promise</var> with a <code>SecurityError</code> and abort these
          steps.
        </li>
        <li>
          If the algorithm is not allowed to show a popup, reject
          <var>promise</var> with a <code>SecurityError</code> and abort these
          steps.
        </li>
        <li>
          <a>Enumerate all devices attached to the system</a>. Let this result
          be <var>enumerationResult</var>.
        </li>
        <li>
          Remove all devices from <var>enumerationResult</var> that do not match
          at least one of the filters in
          <code><var>options</var>.filters</code>.
          <p>
            The UA MAY apply additional origin-based filtering of available
            devices by consulting an authoritative list of device-origin
            mappings or referring to the origin list returned by the <a>Get
            Allowed Origins</a> request.
          </p>
          <p>
            The UA MAY provide additional mechanisms for blacklisting or
            whitelisting specific devices for arbitrary origins.
          </p>
        </li>
        <li>
          Even if <var>enumerationResult</var> is empty, display a prompt to the
          user requesting that the user select a device from it. The UA SHOULD
          show a human-readable name of each device.
        </li>
        <li>
          Wait for the user to have selected a <var>device</var> or cancelled
          the prompt.
        </li>
        <li>
          If the user cancels the prompt, reject <var>promise</var> with a
          <code>NotFoundError</code> and abort these steps.
        </li>
        <li>
          Add <var>device</var> to the current script execution environment's
          <a>allowed devices set</a>.
        </li>
        <li>
          Get the <a>USBDevice</a> object representing <var>device</var> and
          resolve <var>promise</var> with that object.
        </li>
      </ol>

      <section>
        <h3>Events</h3>
        <pre class="idl">
          interface USBConnectionEvent : Event {
            readonly attribute USBDevice device;
          };
        </pre>

        <p>
          When the UA detects a new USB device connected to the host it MUST
          perform the following steps for each script execution environment:
        </p>
        <ol>
          <li>
            Let <var>device</var> be the <a>USBDevice</a> object representing
            the device.
          </li>
          <li>
            If <var>device</var> is not in the <a>allowed devices set</a> for
            the current script execution environment abort these steps.
          </li>
          <li>
            Let <var>event</var> be a new <a>USBConnectionEvent</a>, with the
            <code>device</code> attribute set to <var>device</var>.
          </li>
          <li>
            Fire an event named <dfn>connect</dfn> on <a>navigator.usb</a>,
            using <var>event</var> as the event object.
          </li>
        </ol>
        <p>
          When the UA detects a previously connected USB device has been
          disconnected from the host it MUST perform the following steps for
          each script execution environment:
        </p>
        <ol>
          <li>
            Let <var>device</var> be the <a>USBDevice</a> object representing
            the device.
          </li>
          <li>
            If <var>device</var> is not in the <a>allowed devices set</a> for
            the current script execution environment abort these steps.
          </li>
          <li>
            Let <var>event</var> be a new <a>USBConnectionEvent</a>, with the
            <code>device</code> attribute set to <var>device</var>.
          </li>
          <li>
            Fire an event named <dfn>disconnect</dfn> on <a>navigator.usb</a>,
            using <var>event</var> as the event object.
          </li>
          <li>
            Consider removing <var>device</var> from the <a>allowed devices
            set</a>.
          </li>
        </ol>
      </section>
    </section>

    <section>
      <h2>Device Usage</h2>
      <pre class="idl">
        interface USBDevice {
          readonly attribute DOMString guid;
          readonly attribute octet usbVersionMajor;
          readonly attribute octet usbVersionMinor;
          readonly attribute octet usbVersionSubminor;
          readonly attribute octet deviceClass;
          readonly attribute octet deviceSubclass;
          readonly attribute octet deviceProtocol;
          readonly attribute unsigned short vendorId;
          readonly attribute unsigned short productId;
          readonly attribute octet deviceVersionMajor;
          readonly attribute octet deviceVersionMinor;
          readonly attribute octet deviceVersionSubminor;
          readonly attribute DOMString? manufacturerName;
          readonly attribute DOMString? productName;
          readonly attribute DOMString? serialNumber;
          readonly attribute FrozenArray&lt;USBConfiguration> configurations;
          Promise&lt;void> open();
          Promise&lt;void> close();
          Promise&lt;USBConfiguration> getConfiguration();
          Promise&lt;void> setConfiguration(octet configurationValue);
          Promise&lt;void> claimInterface(octet interfaceNumber);
          Promise&lt;void> releaseInterface(octet interfaceNumber);
          Promise&lt;void> setInterface(octet interfaceNumber, octet alternateSetting);
          Promise&lt;USBInTransferResult> controlTransferIn(USBControlTransferParameters setup, unsigned short length);
          Promise&lt;USBOutTransferResult> controlTransferOut(USBControlTransferParameters setup, optional BufferSource data);
          Promise&lt;void> clearHalt(octet endpointNumber);
          Promise&lt;USBInTransferResult> transferIn(octet endpointNumber, unsigned long length);
          Promise&lt;USBOutTransferResult> transferOut(octet endpointNumber, BufferSource data);
          Promise&lt;void> reset();
        };
      </pre>
      <p dfn-for="USBDevice">
        The <code><dfn>guid</dfn></code> attribute indicates a unique identifier
        string for the device. This identifier SHALL remain consistent for the
        lifetime of a device's connection to the USB host.
      </p>
      <p dfn-for="USBDevice">
        The <code><dfn>usbVersionMajor</dfn></code>,
        <code><dfn>usbVersionMinor</dfn></code> and
        <code><dfn>usbVersionSubminor</dfn></code> attributes declare the USB
        protocol version supported by the device. They SHALL correspond to the
        value of the <code>bcdUSB</code> field of the <a>device descriptor</a>
        such that a value of <code>0xJJMN</code> has major version
        <code>JJ</code>, minor version <code>M</code> and subminor version
        <code>N</code>.
      </p>
      <p dfn-for="USBDevice">
        The <code><dfn>deviceClass</dfn></code>,
        <code><dfn>deviceSubclass</dfn></code> and
        <code><dfn>deviceProtocol</dfn></code> attributes declare the
        communication interface supported by the device. They MUST correspond
        respectively to the values of the <code>bDeviceClass</code>,
        <code>bDeviceSubClass</code> and <code>bDeviceProtocol</code> fields of
        the <a>device descriptor</a>.
      </p>
      <p dfn-for="USBDevice">
        The <code><dfn>vendorId</dfn></code> and
        <code><dfn>productId</dfn></code> attribute declares the vendor ID
        of the device manufacturer and product ID assigned by the device
        manufacturer. They SHALL correspond to the values of the
        <code>idVendor</code> and <code>idProduct</code> fields of the <a>device
        descriptor</a>.
      </p>
      <p dfn-for="USBDevice">
        The <code><dfn>deviceVersionMajor</dfn></code>,
        <code><dfn>deviceVersionMinor</dfn></code> and
        <code><dfn>deviceVersionSubminor</dfn></code> attributes declare the
        device release number as defined by the device manufacturer. It SHALL
        correspond to the value of the <code>bcdDevice</code> field of the
        <a>device descriptor</a> such that a value of <code>0xJJMN</code> has
        major version <code>JJ</code>, minor version <code>M</code> and subminor
        version <code>N</code>.
      </p>
      <p dfn-for="USBDevice">
        The <code><dfn>configurations</dfn></code> attribute contains a list of
        configurations supported by the device. These configurations SHALL be
        populated from the configuration descriptors reported by the device and
        the number of elements in this list SHALL match the value of the
        <code>bNumConfigurations</code> field of the <a>device descriptor</a>.
      </p>
      <p dfn-for="USBDevice">
        The <code><dfn>manufacturerName</dfn></code>,
        <code><dfn>productName</dfn></code> and
        <code><dfn>serialNumber</dfn></code> attributes SHOULD contain the
        values of the string descriptors referenced by the
        <code>iManufacturer</code>, <code>iProduct</code> and
        <code>iSerialNumber</code> fields of the <a>device descriptor</a> if
        each is available.
      </p>
      <p dfn-for="USBDevice">
        The <code><dfn>open</dfn>()</code> method, when invoked, MUST return a
        new promise <var>promise</var> and run the following steps in parallel:
      </p>
      <ol>
        <li>
          If the device is no longer connected to the system, reject
          <var>promise</var> with a <code>NotFoundError</code> and abort these
          steps.
        </li>
        <li>
          If the device is already in the <a>open state</a>, reject
          <var>promise</var> with a <code>InvalidStateError</code> and abort
          these steps.
        </li>
        <li>
          Perform the necessary platform-specific steps to begin a session with
          the device. If these fail for any reason reject <var>promise</var>
          with a <code>NetworkError</code> and abort these steps.
        </li>
        <li>
          Consider the device to be in what will be referred to as the
          <dfn>open state</dfn> and resolve <var>promise</var>.
        </li>
      </ol>
      <p dfn-for="USBDevice">
        The <code><dfn>close</dfn>()</code> method, when invoked, MUST return a
        new promise <var>promise</var> and run the following steps in parallel:
      </p>
      <ol>
        <li>
          If the device is no longer connected to the system, reject
          <var>promise</var> with a <code>NotFoundError</code> and abort these
          steps.
        </li>
        <li>
          If the device is not in the <a>open state</a>, reject
          <var>promise</var> with a <code>InvalidStateError</code> and abort
          these steps.
        </li>
        <li>
          Abort all other algorithms currently running against this device and
          reject their associated promises with an <code>AbortError</code>.
        </li>
        <li>
          Perform the necessary platform-specific steps to release any claimed
          interfaces as if <code><a data-lt="USBDevice.releaseInterface">
          releaseInterface</a>(<var>interfaceNumber</var>)</code> had been
          called for each claimed interface.
        </li>
        <li>
          Perform the necessary platform-specific steps to end the session with
          the device.
        </li>
        <li>
          Take the device out of the <a>open state</a> and resolve
          <var>promise</var>.
        </li>
      </ol>
      <p dfn-for="USBDevice">
        The <code><dfn>getConfiguration</dfn>()</code> method, when invoked,
        MUST return a new promise <var>promise</var> and run the following steps
        in parallel:
      </p>
      <ol>
        <li>
          If the device is no longer connected to the system, reject
          <var>promise</var> with a <code>NotFoundError</code> and abort these
          steps.
        </li>
        <li>
          Let <var>configuration</var> be the active device configuration. If
          the device is unconfigured, reject <var>promise</var> with a
          <code>NotFoundError</code> and abort these steps.
        </li>
        <li>
          Resolve <var>promise</var> with <var>configuration</var>.
        </li>
      </ol>
      <p dfn-for="USBDevice">
        The
        <code><dfn>setConfiguration</dfn>(<var>configurationValue</var>)</code>
        method, when invoked, MUST return a new promise <var>promise</var> and
        run the following steps in parallel:
      </p>
      <ol>
        <li>
          If the device is no longer connected to the system, reject
          <var>promise</var> with a <code>NotFoundError</code> and abort these
          steps.
        </li>
        <li>
          Let <var>configuration</var> be the device configuration with
          <code>bConfigurationValue</code> equal to
          <var>configurationValue</var>. If no such configuration exists, reject
          <var>promise</var> with a <code>NotFoundError</code> and abort these
          steps.
        </li>
        <li>
          If the device is not in the <a>open state</a>, reject
          <var>promise</var> with a <code>InvalidStateError</code> and abort
          these steps.
        </li>
        <li>
          The UA MAY check that the caller <a>is allowed to access
          <var>configuration</var></a>, and if not reject <var>promise</var>
          with a <code>SecurityError</code> and abort these steps.
        </li>
        <li>
          Abort all transfers currently scheduled on endpoints other than the
          <a>default control pipe</a> and reject their associated promises with
          a <code>AbortError</code>.
        </li>
        <li>
          Issue a <code>SET_CONFIGURATION</code> control transfer to the device
          to set <code><var>configurationValue</var></code> as its <a>active
          configuration</a>. If this step fails reject <var>promise</var> with a
          <code>NetworkError</code> and abort these steps.
        </li>
        <li>
          Resolve <var>promise</var>.
        </li>
      </ol>
      <p dfn-for="USBDevice">
        The <code><dfn>claimInterface</dfn>(<var>interfaceNumber</var>)</code>
        method, when invoked, MUST return a new promise and run the following
        steps in parallel:
      </p>
      <ol>
        <li>
          If the device is no longer connected to the system, reject
          <var>promise</var> with a <code>NotFoundError</code> and abort these
          steps.
        </li>
        <li>
          Let <var>interface</var> be the interface in the <a>active
          configuration</a> with <code>bInterfaceNumber</code> equal to
          <var>interfaceNumber</var>. If no such interface exists, reject
          <var>promise</var> with a <code>NotFoundError</code> and abort
          these steps.
        </li>
        <li>
          If the device is not in the <a>open state</a> or <var>interface</var>
          is already in the <a>claimed state</a>, reject <var>promise</var> with
          an <code>InvalidStateError</code> and abort these steps.
        </li>
        <li>
          The UA MAY check that the caller <a>is allowed to access
          <var>interface</var></a>, and if not reject <var>promise</var> with a
          <code>SecurityError</code> and abort these steps.
        </li>
        <li>
          Perform the necessary platform-specific steps to request exclusive
          control over <var>interface</var>. If this fails, reject
          <var>promise</var> with a <code>NetworkError</code> and abort these
          steps.
        </li>
        <li>
          Consider <var>interface</var> to be in what will be referred to as the
          <dfn>claimed state</dfn> and resolve <var>promise</var>.
        </li>
      </ol>
      <p dfn-for="USBDevice">
        The <code><dfn>releaseInterface</dfn>(<var>interfaceNumber</var>)</code>
        method, when invoked, MUST return a new promise <var>promise</var> and
        run the following steps in parallel:
      </p>
      <ol>
        <li>
          If the device is no longer connected to the system, reject
          <var>promise</var> with a <code>NotFoundError</code> and abort these
          steps.
        </li>
        <li>
          Let <var>interface</var> be the interface in the <a>active
          configuration</a> with <code>bInterfaceNumber</code> equal to
          <var>interfaceNumber</var>. If no such interface exists, reject
          <var>promise</var> with a <code>NotFoundError</code> and abort
          these steps.
        </li>
        <li>
          If the device is not in the <a>open state</a> or <var>interface</var>
          is not in the <a>claimed state</a>, reject <var>promise</var> with an
          <code>InvalidStateError</code> and abort these steps.
        </li>
        <li>
          Perform the necessary platform-specific steps to reliquish exclusive
          control over <var>interface</var>.
        </li>
        <li>
          Take <var>interface</var> out of the <a>claimed state</a> and resolve
          <var>promise</var>.
        </li>
      </ol>
      <p dfn-for="USBDevice">
        The <code><dfn>setInterface</dfn>(<var>interfaceNumber</var>,
        <var>alternateSetting</var>)</code> method, when invoked, MUST return
        a new promise <var>promise</var> and run the following steps in
        parallel:
      </p>
      <ol>
        <li>
          If the device is no longer connected to the system, reject
          <var>promise</var> with a <code>NotFoundError</code> and abort these
          steps.
        </li>
        <li>
          Let <var>interface</var> be the interface in the <a>active
          configuration</a> with <code>bInterfaceNumber</code> equal to
          <var>interfaceNumber</var>. If no such interface exists, reject
          <var>promise</var> with a <code>NotFoundError</code> and abort
          these steps.
        </li>
        <li>
          If the device is not in the <a>open state</a> or <var>interface</var>
          is not in the <a>claimed state</a>, reject <var>promise</var> with an
          <code>InvalidStateError</code> and abort these steps.
        </li>
        <li>
          Abort all transfers currently scheduled on endpoints associated with
          the previously selected alternate setting of <var>interface</var> and
          reject their associated promises with a <code>AbortError</code>.
        </li>
        <li>
          Issue a <code>SET_INTERFACE</code> control transfer to the device
          to set <code><var>alternateSetting</var></code> as the current
          configuration of <var>interface</var>. If this step fails reject
          <var>promise</var> with a <code>NetworkError</code> and abort these
          steps.
        </li>
        <li>
          Resolve <var>promise</var>.
        </li>
      </ol>
      <p dfn-for="USBDevice">
        The <code><dfn>controlTransferIn</dfn>(<var>setup</var>,
        <var>length</var>)</code> method, when invoked, MUST return
        a new promise <var>promise</var> and run the following steps in
        parallel:
      </p>
      <ol>
        <li>
          If the device is no longer connected to the system, reject
          <var>promise</var> with a <code>NotFoundError</code> and abort these
          steps.
        </li>
        <li>
          If the device is not in the <a>open state</a>,
          reject <var>promise</var> with an <code>InvalidStateError</code> and
          abort these steps.
        </li>
        <li>
          <a>Check the validity of the control transfer parameters</a> and abort
          these steps if <var>promise</var> is rejected.
        </li>
        <li>
          If <var>length</var> is greater than the <code>wMaxPacketSize0</code>
          field of the device's <a>device descriptor</a>, reject
          <var>promise</var> with a <code>TypeError</code> and abort these
          steps.
        </li>
        <li>
          Let <var>result</var> be a new <a>USBInTransferResult</a> and let
          <var>buffer</var> be a new <code>ArrayBuffer</code> of
          <var>length</var> bytes.
        </li>
        <li>
          Issue a control transfer with the setup packet parameters provided in
          <var>setup</var> and the data transfer direction in
          <code>bmRequestType</code> set to "device to host" and
          <code>wLength</code> set to <var>length</var>.
        </li>
        <li>
          If the device responds with data, store the first <var>length</var>
          bytes of this data in <var>buffer</var> and set <var>result.data</var>
          to <var>buffer</var>.
        </li>
        <li>
          If the device responds by stalling the default control pipe set
          <var>result.status</var> to <code>"stall"</code>.
        </li>
        <li>
          If more than <var>length</var> bytes are received set
          <var>result.status</var> to <code>"babble"</code> and otherwise set it
          to <code>"ok"</code>.
        </li>
        <li>
          If the transfer fails for any other reason reject <var>promise</var>
          with a <code>NetworkError</code> and abort these steps.
        </li>
        <li>
          Resolve <var>promise</var> with <var>result</var>.
        </li>
      </ol>
      <p dfn-for="USBDevice">
        The <code><dfn>controlTransferOut</dfn>(<var>setup</var>,
        <var>data</var>)</code> method, when invoked, must return a new promise
        <var>promise</var> and run the following steps in parallel:
      </p>
      <ol>
        <li>
          If the device is no longer connected to the system, reject
          <var>promise</var> with a <code>NotFoundError</code> and abort these
          steps.
        </li>
        <li>
          If the device is not in the <a>open state</a>,
          reject <var>promise</var> with an <code>InvalidStateError</code> and
          abort these steps.
        </li>
        <li>
          <a>Check the validity of the control transfer parameters</a> and abort
          these steps if <var>promise</var> is rejected.
        </li>
        <li>
          If <var>data.length</var> is greater than the
          <code>wMaxPacketSize0</code> field of the device's
          <a>device descriptor</a>, reject <var>promise</var> with a
          <code>TypeError</code> and abort these steps.
        </li>
        <li>
          Issue a control transfer with the <a>setup packet</a> populated by
          <var>setup</var> and the data transfer direction in
          <code>bmRequestType</code> set to "host to device" and
          <code>wLength</code> set to <var>data.length</var>. Transmit
          <var>data</var> in the <a>data stage</a> of the transfer.
        </li>
        <li>
          Let <var>result</var> be a new <a>USBOutTransferResult</a>.
        </li>
        <li>
          If the device responds by stalling the default control pipe set
          <var>result.status</var> to <code>"stall"</code>.
        </li>
        <li>
          If the device acknowledges the transfer set <var>result.status</var>
          to <code>"ok"</code> and <var>result.bytesWritten</var> to
          <var>data.length</var>.
        </li>
        <li>
          If the transfer fails for any other reason reject <var>promise</var>
          with a <code>NetworkError</code> and abort these steps.
        </li>
        <li>
          Resolve <var>promise</var> with <var>result</var>.
        </li>
      </ol>
      <p dfn-for="USBDevice">
        The <code><dfn>clearHalt</dfn>(<var>direction</var>,
        <var>endpointNumber</var>)</code> method, when invoked, MUST return a
        new promise <var>promise</var> and run the following steps in parallel:
      </p>
      <ol>
        <li>
          If the device is no longer connected to the system, reject
          <var>promise</var> with a <code>NotFoundError</code> and abort these
          steps.
        </li>
        <li>
          Let <var>endpoint</var> be the endpoint in the <a>active
          configuration</a> with <code>bEndpointAddress</code> corresponding to
          <var>direction</var> and <var>endpointNumber</var>. If no such
          endpoint exists reject <var>promise</var> and abort these steps.
        </li>
        <li>
          If the device is not in the <a>open state</a> or the interface
          containing <var>endpoint</var> is not in the <a>claimed state</a>,
          reject <var>promise</var> with an <code>InvalidStateError</code> and
          abort these steps.
        </li>
        <li>
          Issue a <code>CLEAR_FEATURE</code> control transfer to the device
          to clear the stall condition on <var>endpoint</var>.
        </li>
        <li>
          On failure reject <var>promise</var> with a <code>NetworkError</code>,
          otherwise resolve <var>promise</var>.
        </li>
      </ol>
      <p dfn-for="USBDevice">
        The <code><dfn>transferIn</dfn>(<var>endpointNumber</var>,
        <var>length</var>)</code> method, when invoked, MUST return a new
        promise <var>promise</var> and run the following steps in parallel:
      </p>
      <ol>
        <li>
          If the device is no longer connected to the system, reject
          <var>promise</var> with a <code>NotFoundError</code> and abort these
          steps.
        </li>
        <li>
          Let <var>endpoint</var> be the IN endpoint in the <a>active
          configuration</a> with <code>bEndpointAddress</code> corresponding to
          <var>endpointNumber</var>. If there is no such endpoint reject
          <var>promise</var> with a <code>NotFoundError</code> and abort these
          steps.
        </li>
        <li>
          If the device is not in the <a>open state</a> or the interface
          containing <var>endpoint</var> is not in the <a>claimed state</a>,
          reject <var>promise</var> with an <code>InvalidStateError</code> and
          abort these steps.
        </li>
        <li>
          As appropriate for <var>endpoint</var> enqueue a bulk or interrupt
          IN transfer on <var>endpoint</var> with a buffer sufficient to receive
          <var>length</var> bytes of data from the device.
        </li>
        <li>
          Let <var>result</var> be a new <a>USBInTransferResult</a>.
        </li>
        <li>
          If data is returned as part of this transfer let <var>buffer</var> be
          a new ArrayBuffer of exactly the length of the data received and set
          <var>result.data</var> to <var>buffer</var>.
        </li>
        <li>
          If the device responds with more than <var>length</var> bytes of data
          set <var>result.status</var> to <code>"babble"</code>.
        <li>
          If the transfer ends because <var>endpoint</var> is stalled set
          <var>result.status</var> to <code>"stall"</code>.
        </li>
        <li>
          If the device acknowledges the complete transfer set
          <var>result.status</var> to <code>"ok"</code>.
        </li>
        <li>
          If the transfer fails for any other reason reject <var>promise</var>
          with a <code>NetworkError</code> and abort these steps.
        </li>
        <li>
          Resolve <var>promise</var> with <var>result</var>.
        </li>
      </ol>
      <p dfn-for="USBDevice">
        The <code><dfn>transferOut</dfn>(<var>endpointNumber</var>,
        <var>data</var>)</code> method, when invoked, MUST return a new promise
        <var>promise</var> and run the following steps in parallel:
      </p>
      <ol>
        <li>
          If the device is no longer connected to the system, reject
          <var>promise</var> with a <code>NotFoundError</code> and abort these
          steps.
        </li>
        <li>
          Let <var>endpoint</var> be the OUT endpoint in the <a>active
          configuration</a> with <code>bEndpointAddress</code> corresponding to
          <var>endpointNumber</var>. If there is no such endpoint reject
          <var>promise</var> with a <code>NotFoundError</code> and abort these
          steps.
        </li>
        <li>
          If the device is not in the <a>open state</a> or the interface
          containing <var>endpoint</var> is not in the <a>claimed state</a>,
          reject <var>promise</var> with an <code>InvalidStateError</code> and
          abort these steps.
        </li>
        <li>
          As appropriate for <var>endpoint</var> enqueue a bulk or interrupt
          OUT transfer on <var>endpoint</var> to transmit <var>data</var> to the
          device.
        </li>
        <li>
          Let <var>result</var> be a new <a>USBOutTransferResult</a>.
        </li>
        <li>
          Set <var>result.bytesWritten</var> to the amount of data successfully
          sent to the device.
        </li>
        <li>
          If the endpoint is stalled set <var>result.status</var> to
          <code>"stall"</code>.
        </li>
        <li>
          If the device acknowledges the complete transfer set
          <var>result.status</var> to <code>"ok"</code>.
        </li>
        <li>
          If the transfer fails for any other reason reject <var>promise</var>
          with a <code>NetworkError</code> and abort these steps.
        </li>
        <li>
          Resolve <var>promise</var> with <var>result</var>.
        </li>
      </ol>
      <p dfn-for="USBDevice">
        The <code><dfn>reset</dfn>()</code> method, when invoked, must return a
        new promise <var>promise</var> and run the following steps in parallel:
      </p>
      <ol>
        <li>
          If the device is not in the <a>open state</a>,
          reject <var>promise</var> with an <code>InvalidStateError</code> and
          abort these steps.
        </li>
        <li>
          If the device is no longer connected to the system, reject
          <var>promise</var> with a <code>NotFoundError</code> and abort these
          steps.
        </li>
        <li>
          Abort all operations on the device and reject their associated
          promises with an <code>AbortError</code>.
        </li>
        <li>
          Perform the necessary platform-specific operation to soft reset the
          device.
        </li>
        <li>
          On failure reject <var>promise</var> with a <code>NetworkError</code>,
          otherwise resolve <var>promise</var>.
        </li>
        <p class="issue">
          What configuration is the device in after it resets?
        </p>
      </ol>

      <section>
        <h3>Transfers</h3>
        <pre class="idl">
          enum USBRequestType {
            "standard",
            "class",
            "vendor"
          };

          enum USBRecipient {
            "device",
            "interface",
            "endpoint",
            "other"
          };

          enum USBTransferStatus {
            "ok",
            "stall",
            "babble"
          };

          dictionary USBControlTransferParameters {
            required USBRequestType requestType;
            required USBRecipient recipient;
            required octet request;
            required unsigned short value;
            required unsigned short index;
          };

          interface USBInTransferResult {
            readonly attribute ArrayBuffer data;
            readonly attribute USBTransferStatus status;
          };

          interface USBOutTransferResult {
            readonly attribute unsigned long bytesWritten;
            readonly attribute USBTransferStatus status;
          };
        </pre>

        <p>
          A <dfn>control transfer</dfn> is a special class of USB traffic most
          commonly used for configuring a device. It consists of three stages:
          setup, data and status. In the <dfn>setup stage</dfn> a <dfn>setup
          packet</dfn> is transmitted to the device containing request
          parameters including the transfer direction and size of the data to
          follow. In the <dfn>data stage</dfn> that data is either sent to or
          received from the device. In the <dfn>status stage</dfn> successful
          handling of the request is acknowledged or a failure is signaled.
        </p>
        <p>
          All USB devices MUST have a <dfn>default control pipe</dfn> which is
          <var>endpointNumber</var> <code>0</code>.
        </p>
        <p dfn-for="USBControlTransferParameters">
          The <code><dfn>requestType</dfn></code> attribute populates part of
          the <code>bmRequestType</code> field of the <a>setup packet</a> to
          indicate whether this request is part of the USB standard, a
          particular USB device class specification or a vendor-specific
          protocol.
        </p>
        <p dfn-for="USBControlTransferParameters">
          The <code><dfn>recipient</dfn></code> attribute populates part of the
          <code>bmRequestType</code> field of the <a>setup packet</a> to
          indicate whether the control transfer is addressed to the entire
          device, or a specific interface or endpoint.
        </p>
        <p dfn-for="USBControlTransferParameters">
          The <code><dfn>request</dfn></code> attribute populates the
          <code>bRequest</code> field of the <a>setup packet</a>. Valid requests
          are defined by the USB standard, USB device class specifications or
          the device vendor.
        </p>
        <p dfn-for="USBControlTransferParameters">
          The <code><dfn>value</dfn></code> and <code><dfn>index</dfn></code>
          attributes populate the <code>wValue</code> and <code>wIndex</code>
          fields of the <a>setup packet</a> respectively. The meaning of these
          fields depends on the request being made.
        </p>
        <p>
          To <dfn>check the validity of the control transfer parameters</dfn>
          perform the following steps:
        </p>
        <ol>
          <li>
            Let <var>setup</var> be the <a>USBControlTransferParameters</a>
            created for the transfer.
          </li>
          <li>
            Let <var>promise</var> be the promise created for the transfer.
          </li>
          <li>
            Let <var>configuration</var> be the <a>active configuration</a>. If
            the device is not configured abort these steps.
          </li>
          <li>
            If <var>setup.recipient</var> is <code>"device"</code> or
            <code>"other"</code> the UA MAY check that the caller <a>is allowed
            to access <var>configuration</var></a>, and if not reject
            <var>promise</var> with a <code>SecurityError</code> and abort these
            steps.
          </li>
          <li>
            If <var>setup.recipient</var> is <code>"interface"</code>, perform
            the following steps:
            <ol>
              <li>
                Let <var>interfaceNumber</var> be the lower 8 bits of
                <var>setup.wIndex</var>.
              </li>
              <li>
                Let <var>interface</var> be the interface in the <var>
                configuration</var> with <code>bInterfaceNumber</code> equal to
                <var>interfaceNumber</var>. If no such interface exists, reject
                <var>promise</var> with a <code>NotFoundError</code> and abort
                these steps.
              </li>
              <li>
                If <var>interface</var> is not in the <a>claimed state</a>,
                reject <var>promise</var> with an
                <code>InvalidStateError</code> and abort these steps.
              </li>
              <li>
                The UA MAY check that the caller <a>is allowed to access
                <var>interface</var></a>, and if not reject <var>promise</var>
                with a <code>SecurityError</code>.
              </li>
            </ol>
          </li>
          <li>
            If <var>setup.recipient</var> is <code>"endpoint"</code>, run the
            following steps:
            <ol>
              <li>
                Let <var>endpointNumber</var> be defined as the lower 4 bits of
                <var>setup.wIndex</var>.
              </li>
              <li>
                Let <var>direction</var> be defined as <code>"in"</code> if the
                8th bit of <var>setup.wIndex</var> is <code>1</code> and
                <code>"out"</code> otherwise.
              </li>
              <li>
                Let <var>endpoint</var> be the endpoint in the <a>active
                configuration</a> with <code>bEndpointAddress</code>
                corresponding to <var>direction</var> and
                <var>endpointNumber</var>. If no such endpoint exists, reject
                <var>promise</var> with a <code>NotFoundError</code> and abort
                these steps.
              </li>
              <li>
                Let <var>interface</var> be the interface in which
                <var>endpoint</var> is defined. If <var>interface</var> is not
                in the <a>claimed state</a>, reject <var>promise</var> with an
                <code>InvalidStateError</code>.
              </li>
              <li>
                The UA MAY check that the caller <a>is allowed to access
                <var>interface</var></a>, and if not reject <var>promise</var>
                with a <code>SecurityError</code>.
              </li>
            </ol>
          </li>
        </ol>
      </section>

      <section>
        <h3>Configurations</h3>
        <pre class="idl">
          [Constructor(USBDevice device, octet configurationValue)]
          interface USBConfiguration {
            readonly attribute octet configurationValue;
            readonly attribute DOMString? configurationName;
            readonly attribute FrozenArray&lt;USBInterface> interfaces;
          };
        </pre>
        <p dfn-for="USBConfiguration">
          Each device configuration SHALL have a unique
          <code><dfn>configurationValue</dfn></code> that matches the
          <code>bConfigurationValue</code> fields of the <a>configuration
          descriptor</a> that defines it.
        </p>
        <p dfn-for="USBConfiguration">
          The <code><dfn>configurationName</dfn></code> attribute SHOULD contain
          the value of the string descriptor referenced by the
          <code>iConfiguration</code> field of the <a>configuration
          descriptor</a>, if available.
        </p>
        <p dfn-for="USBConfiguration">
          The <code><dfn>interfaces</dfn></code> attribute SHALL contain a list of
          interfaces exposed by this device configuration. These interfaces SHALL
          by populated from the <a>interface descriptors</a> contained within
          this <a>configuration descriptor</a>.
        </p>
        <p class="issue">
          Include some non-normative information about device configurations
        </p>
      </section>

      <section>
        <h3>Interfaces</h2>
        <pre class="idl">
          [Constructor(USBConfiguration configuration, octet interfaceNumber)]
          interface USBInterface {
            readonly attribute octet interfaceNumber;
            readonly attribute FrozenArray&lt;USBAlternateInterface> alternates;
          };

          [Constructor(USBInterface deviceInterface, octet alternateSetting)]
          interface USBAlternateInterface {
            readonly attribute octet alternateSetting;
            readonly attribute octet interfaceClass;
            readonly attribute octet interfaceSubclass;
            readonly attribute octet interfaceProtocol;
            readonly attribute DOMString? interfaceName;
            readonly attribute FrozenArray&lt;USBEndpoint> endpoints;
          };
        </pre>
        <p dfn-for="USBInterface">
          Each interface provides a collection of
          <code><dfn>alternates</dfn></code> identified by a single
          <code>bInterfaceNumber</code> field found in their
          <a>interface descriptors</a>. The
          <code><dfn>interfaceNumber</dfn></code> attribute MUST match this
          field.
        </p>
        <p dfn-for="USBAlternateInterface">
          Each alternative interface configuration SHALL have a unique
          <code><dfn>alternateSetting</dfn></code> within a given interface that
          matches the <code>bAlternateSetting</code> field of the <a>interface
          descriptor</a> that defines it.
        </p>
        <p dfn-for="USBAlternateInterface">
          The <code><dfn>interfaceClass</dfn></code>,
          <code><dfn>interfaceSubclass</dfn></code> and
          <code><dfn>interfaceProtocol</dfn></code> attributes declare the
          communication interface supported by the interface. They MUST correspond
          respectively to the values of the <code>bInterfaceClass</code>,
          <code>bInterfaceSubClass</code> and <code>bInterfaceProtocol</code>
          fields of the <a>interface descriptor</a>.
        </p>
        <p dfn-for="USBAlternateInterface">
          The <code><dfn>interfaceName</dfn></code> attribute SHOULD contain the
          value of the string descriptor referenced by the
          <code>iInterface</code> field of the <a>interface descriptor</a>, if
          available.
        </p>
        <p dfn-for="USBAlternateInterface">
          The <code><dfn>endpoints</dfn></code> attribute SHALL contain a list of
          endpoints exposed by this interface. These endpoints SHALL by populated
          from the endpoint descriptors contained within this <a>interface
          descriptor</a> and the number of elements in this sequence SHALL match
          the value of the <code>bNumEndpoints</code> field of the <a>interface
          descriptor</a>.
        </p>
        <p>
          A device's <dfn>active configuration</dfn> is the combination of the
          <a>USBConfiguration</a> selected by calling
          <code><a data-lt="USBDevice.setConfiguration">
          setConfiguration</a>(<var>configurationValue</var>)</code> and the set
          of <a>UsbAlternateInterface</a>s selected by calling
          <code><a data-lt="USBDevice.setInterface">
          setInterface</a>(<var>interfaceNumber</var>,
          <var>alternateSetting</var>)</code>.
          A device MAY, by default, be left in an unconfigured state, referred
          to as configuration <code>0</code> or may automatically be set to
          whatever configuration has <code>bConfigurationValue</code> equal to
          <code>1</code>. When a configuration is set all interfaces within that
          configuration automatically have the <a>USBAlternateInterface</a> with
          <code>bAlternateSetting</code> equal to <code>0</code> selected by
          default. It is therefore unnecessary to call
          <code><a data-lt="USBDevice.setInterface">
          setInterface</a>(<var>interfaceNumber</var>, 0)</code> for each
          interface when opening a device.
        </p>
      </section>

      <section>
        <h3>Endpoints</h2>
        <pre class="idl">
          enum USBDirection {
            "in",
            "out"
          };

          enum USBEndpointType {
            "bulk",
            "interrupt",
            "isochronous"
          };

          [Constructor(USBAlternateInterface alternate, octet endpointNumber, USBDirection direction)]
          interface USBEndpoint {
            readonly attribute octet endpointNumber;
            readonly attribute USBDirection direction;
            readonly attribute USBEndpointType type;
            readonly attribute unsigned long packetSize;
          };
        </pre>
        <p dfn-for="USBEndpoint">
          Each endpoint within a particular device configuration SHALL have a
          unique combination of <code>endpointNumber</code> and
          <code>direction</code>. The <code><dfn>endpointNumber</dfn></code>
          MUST equal the 4 least significant bits of the
          <code>bEndpointAddress</code> field of the <a>endpoint descriptor</a>
          defining the endpoint.
        </p>
        <p dfn-for="USBEndpoint">
          The <code><dfn>direction</dfn></code> attribute declares the transfer
          direction supported by this endpoint and is equal to <code>"in"</code>
          if the most significant bit of the <code>bEndpointAddress</code> is
          set and <code>"out"</code> otherwise. An endpoint may either carry
          data <code>IN</code> from the device to host or <code>OUT</code> from
          host to device.
        </p>
        <p dfn-for="USBEndpoint">
          The <code><dfn>type</dfn></code> attribute declares the type of data
          transfer supported by this endpoint.
        </p>
        <p dfn-for="USBEndpoint">
          The <code><dfn>packetSize</dfn></code> attribute declares the packet
          size employed by this endpoint and MUST be equal to the value of the
          <code>wMaxPacketSize</code> of the <a>endpoint descriptor</a> defining
          it. In a High-Speed, High-Bandwidth endpoint this value will include the
          multiplication factor provided by issuing multiple transactions per
          microframe. In a SuperSpeed device this value will include the
          multiplication factor provided by the <code>bMaxBurst</code> field of
          the SuperSpeed Endpoint Companion descriptor.
        </p>
      </section>
    </section>

    <section>
      <h2>Terminology</h2>
      <p>
        This specification uses several terms taken from [[USB31]]. While
        reference is made to version 3.1 of the Universal Serial Bus many of
        these concepts exist in previous versions as well. Significant
        differences between USB versions that have bearing on this specification
        will be called out explicitly.
      </p>
      <p>
        <dfn>Descriptors</dfn> are binary data structures that can be read from
        a device and describe its properties and function:
        <ul>
          <li>
            The <dfn>device descriptor</dfn> contains information applicable to
            the entire devices and is described in section 9.6.1 of [[USB31]].
          </li>
          <li>
            A <dfn>configuration descriptor</dfn> describes a particular set of
            device interfaces and endpoints that can be selected by the host.
            Its fields are described in section 9.6.3 of [[USB31]].
          </li>
          <li>
            An <dfn data-lt="interface descriptor|interface descriptors">interface descriptor</dfn>
            describes the interface of a particular functional component of a
            device including its protocol and communication endpoints. Its
            fields are described in section 9.6.5 of [[USB31]].
          </li>
          <li>
            An <dfn>interface association descriptor</dfn> creates an
            association between multiple interfaces that are part of a single
            functional unit of a device. Its fields are described in section
            9.6.4 of [[USB31]].
          </li>
          <li>
            An <dfn>endpoint descriptor</dfn> describes a channel through which
            data is either sent to or received from the device. Its fields are
            described in section 9.6.6 of [[USB31]].
          </li>
        </ul>
      </p>
      <p>
        The <dfn>Binary Object Store</dfn>
        (<abbr title="Binary Object Store">BOS</abbr>) is an additional set of
        descriptors that are more free-form than the standard device
        descriptors. Of note is the <dfn>Platform Descriptor</dfn> type which
        allows third parties (such as this specification) to declare their own
        types of descriptors. Each of these is identified by a UUID. The Binary
        Object Store is described in section 9.6.2 of [[USB31]].
      </p>
    </section>
  </body>
</html>
