<!DOCTYPE html>
<html>
  <head>
    <title>WebUSB API</title>
    <meta charset="utf-8">
    <script src="http://www.w3.org/Tools/respec/respec-w3c-common"
            async class="remove"></script>
    <script class="remove">
      var respecConfig = {
        specStatus: "unofficial",
        shortName: "webusb-api",
        editors: [
          {
            name: "Reilly Grant",
            company: "Google",
            companyUrl: "https://www.google.com/"
          }, {
            name: "Ken Rockot",
            company: "Google",
            companyUrl: "https://www.google.com/"
          }
        ]
      };
    </script>
  </head>
  <body>
    <section id="abstract">
      <p>
        This document describes an API for direct access to Universal Serial Bus
        devices from web pages.
      </p>
    </section>

    <section id="sotd">
    </section>

    <section class="informative">
      <h2>Introduction</h2>
      <p>
        Today when you connect a device to your computer you hope that somehow
        it will find the right driver and it will Just Work&trade;. For lots of
        devices it does because there are standardized drivers for things like
        keyboards, mice, hard drives and webcams built into the operating
        system. What about the long tail of unusual devices or the next
        generation of gadgets that haven't been standardized yet? WebUSB takes
        "plug and play" to the next level by connecting devices to the software
        that drives them across any platform by harnessing the power of web
        technologies.
      </p>
      <p>
        WebUSB does not attempt to provide a general mechanism for any web page
        to connect to any USB device. Historically USB hosts and devices have
        trusted each other too much to let arbitrary pages connect to them.
        There are published attacks against USB devices that will accept
        unsigned firmware updates that cause them to become malicious and attack
        the host they are connected to; exploiting the trust relationship in
        both directions.
      </p>
      <p>
        Instead USB devices will be associated with a web origin and can only be
        connected to from a page from the same origin. New devices (or firmware
        updates) may include a list of acceptable origins that the user agent
        can query, similar to the CORS mechanism for HTTP requests. Device
        vendors may enable existing devices by registering them in an open
        directory which maps device IDs to acceptable origins.
      </p>
    </section>

    <section>
      <h2>Device Enumeration</h2>
      <pre class="idl">
        dictionary USBDeviceFilter {
          unsigned short vendorId;
          unsigned short productId;
          octet interfaceClass;
          octet interfaceSubclass;
          octet interfaceProtocol;
        };

        dictionary USBDeviceEnumerationOptions {
          required sequence&lt;USBDeviceFilter> filters;
        };

        [NoInterfaceObject]
        interface USBDeviceEnumeration {
          Promise&lt;sequence&lt;USBDevice>> getDevices(USBDeviceEnumerationOptions options);
        };
      </pre>
      <p dfn-for="USBDeviceEnumeration">
        The <code><dfn>getDevices</dfn>(<var>options</var>)</code> method, when
        invoked, MUST return a new promise <var>promise</var> and run the
        following steps in parallel:
      <p>
      <ol>
        <li>
          Enumerate all devices which individually match at least one of the
          filters in <code><var>options</var>.filters</code>.
          <p>
            The UA SHOULD apply additional origin-based filtering of available
            devices by consulting an authoritative list of device-origin
            mappings or referring to the origin list specified in the device's
            <dfn>Binary Object Store</dfn>
            (<abbr title="Binary Object Store">BOS</abbr>).
          </p>
          <p>
            The UA MAY provide additional mechanisms for blacklisting or
            whitelisting specific devices for arbitrary origins.
          </p>
          <p class="note" title="USBDeviceFilter members">
          </p>
          <p class="note" title="Binary Object Store">
            <span class="issue">TODO: More detail about this.</span>
          </p>
        </li>
        <li>
          Get the sequence of <a>USBDevice</a> objects representing all the
          devices which passed the filtering stage and resolve
          <var>promise</var> with the result.
        </li>
      </ol>
    </section>

    <section>
      <h2>Device Usage</h2>
      <pre class="idl">
        enum USBRequestType {
          "standard",
          "class",
          "vendor"
        };

        enum USBRecipient {
          "device",
          "interface",
          "endpoint"
        };

        dictionary USBControlTransferParameters {
          required USBRequestType requestType;
          required USBRecipient recipient;
          required octet request;
          required unsigned short value;
          required unsigned short index;
        };

        [NoInterfaceObject]
        interface USBDevice {
          readonly attribute unsigned short vendorId;
          readonly attribute unsigned short productId;
          readonly attribute USBConfiguration[] configurations;
          Promise&lt;ArrayBuffer> controlTransferIn(USBControlTransferParameters parameters, unsigned short length);
          Promise&lt;void> controlTransferOut(USBControlTransferParameters parameters, optional ArrayBuffer data);
          Promise&lt;void> reset();
        };
      </pre>
      <p dfn-for="USBDevice">
        <code><dfn>controlTransferIn</dfn>(<var>parameters</var>, <var>length</var>)</code>
        issues a control transfer to the device through its default endpoint.
        <code><var>length</var></code> bytes of data will be read from the
        device during the <code>IN</code> phase of the transaction.
      </p>
      <p dfn-for="USBDevice">
        <code><dfn>controlTransferOut</dfn>(<var>parameters</var>, <var>data</var>)</code>
        issues a control transfer to the device through its default endpoint.
        If provided, the contents of the <code><var>data</var></code> buffer
        will be sent to the device during the OUT phase of the transaction.
        The <code>wLength</code> field of the <code>SETUP</code> packet will
        be populated with the length of this buffer.
      </p>
      <p dfn-for="USBDevice">
        <code><dfn>reset</dfn>()</code> resets the device.
      </p>
      <p class="issue">
        Concepts like transaction phases, packet contents, and device reset
        should be discussed in some additional detail with references to the
        USB spec.
      </p>
    </section>

    <section>
      <h2>Device Configurations</h2>
      <pre class="idl">
        [NoInterfaceObject]
        interface USBConfiguration {
          readonly attribute octet configurationValue;
          readonly attribute USBInterface[] interfaces;
          Promise&lt;void> select();
        };
      </pre>
      <p dfn-for="USBConfiguration">
        <code><dfn>select</dfn>()</code> issues an appropriate SET_CONFIGURATION
        control request to set this configuration as the device's current
        configuration.
      </p>
      <p class="issue">
        Document configurationValue.
      </p>
      <p class="issue">
        Include some non-normative information about device configurations
      </p>
    </section>

    <section>
      <h2>Device Interfaces</h2>
      <pre class="idl">
        [NoInterfaceObject]
        interface USBInterface {
          readonly attribute octet interfaceNumber;
          readonly attribute octet alternateSetting;
          readonly attribute USBEndpoint[] endpoints;
          Promise&lt;void> claim();
          Promise&lt;void> release();
          Promise&lt;void> select();
        };
      </pre>
      <p dfn-for="USBInterface">
        The <code><dfn>claim</dfn>()</code> method requests that control over
        the interface be granted to the UA.
      </p>
      <p dfn-for="USBConfiguration">
        The <code><dfn>release</dfn>()</code> method releases the UA's control
        over the interface if previously granted.
      </p>
      <p dfn-for="USBConfiguration">
        Issues the appropriate <code>SET_INTERFACE</code> request to select this
        alternate interface.
      </p>
      <p class="issue">
        Explain alternate interface selection.
      </p>
    </section>

    <section>
      <h2>Data Transfer Endpoints</h2>
      <pre class="idl">
        enum USBDirection {
          "in",
          "out"
        };

        [NoInterfaceObject]
        interface USBEndpoint {
          readonly attribute octet endpointNumber;
          readonly attribute USBDirection direction;
        };

        [NoInterfaceObject]
        interface USBBulkInterruptEndpoint : USBEndpoint {
          Promise&lt;void> clearHalt();
          Promise&lt;ArrayBuffer> transferIn(unsigned long length);
          Promise&lt;unsigned long> transferOut(ArrayBuffer data);
        };

        [NoInterfaceObject]
        interface USBIsochronousEndpoint : USBEndpoint {
          Promise&lt;ArrayBuffer[]> transferIn(unsigned long[] packetLengths);
          Promise&lt;unsigned long[]> transferOut(ArrayBuffer[] packets);
        };
      </pre>
    </section>
  </body>
</html>
