<!DOCTYPE html>
<html>
  <head>
    <title>WebUSB API</title>
    <meta charset="utf-8">
    <script src="https://www.w3.org/Tools/respec/respec-w3c-common"
            async class="remove"></script>
    <script class="remove">
      var respecConfig = {
        specStatus: "unofficial",
        shortName: "webusb-api",
        editors: [
          {
            name: "Reilly Grant",
            company: "Google",
            companyUrl: "https://www.google.com/"
          }, {
            name: "Ken Rockot",
            company: "Google",
            companyUrl: "https://www.google.com/"
          }
        ],

        localBiblio: {
          "USB31": {
            href: "http://www.usb.org/developers/docs/usb_31_060115.zip",
            title: "Universal Serial Bus 3.1 Specification",
            publisher: "USB Implementors Forum",
            date: "26 July 2013",
          }
        }
      };
    </script>
    <style>
      table {
        border-collapse: collapse;
        border-left-style: hidden;
        border-right-style: hidden;
        text-align: left;
      }
      table caption {
        font-weight: bold;
        padding: 3px;
        text-align: left;
      }
      table td, table th {
        border: 1px solid black;
        padding: 3px;
      }
    </style>
  </head>
  <body>
    <section id="abstract">
      <p>
        This document describes an API for direct access to Universal Serial Bus
        devices from web pages.
      </p>
    </section>

    <section id="sotd">
    </section>

    <section class="informative">
      <h2>Introduction</h2>
      <p>
        Today when you connect a device to your computer you hope that somehow
        it will find the right driver and it will Just Work&trade;. For lots of
        devices it does because there are standardized drivers for things like
        keyboards, mice, hard drives and webcams built into the operating
        system. What about the long tail of unusual devices or the next
        generation of gadgets that haven't been standardized yet? WebUSB takes
        "plug and play" to the next level by connecting devices to the software
        that drives them across any platform by harnessing the power of web
        technologies.
      </p>
    </section>

    <section>
      <h2>Security and Privacy Considerations</h2>
      <p>
        USB hosts and devices historically trust each other. There are published
        attacks against USB devices that will accept unsigned firmware updates.
        These vulnerabilities permit an attacker to gain a foothold in the
        device and attack the original host or any other host to which they are
        later connected. For this reason WebUSB does not attempt to provide a
        mechanism for any web page to connect to arbitrary devices.
      </p>
      <p>
        Direct access to peripherals also poses a privacy risk. Knowing the make
        and model of connected devices provides additional bits of entropy for
        fingerprinting. If devices also posess some form of serial number then
        they can be uniquely identifying. Additionally a device may have access
        to data about its environment or directly store user data.
      </p>
      <p>
        For this reason two checks SHOULD be combined before a site is granted
        access to a device. First, so that the device can protect itself from
        malicious sites a set of allowed origins MUST be read from the device
        (or from a public registry) and checked against the requesting origin.
        Second, so that the user is protected from malicious sites the UA SHOULD
        prompt the user for authorization to allow the site to detect the
        presense of a device and connect to it.
      </p>
      <p>
        To help ensure that only the entity the user approved for access
        actually has access, this specification requires that only secure
        contexts as described in [[powerful-features]] can access USB devices.
      </p>
    </section>

    <section>
      <h2>Device Requirements</h2>
      <p>
        To be supported by a page using this API a USB device MUST provide
        information to the UA about the origins authorized to connect to it and
        MAY also provide a landing page that the UA MAY direct the user to
        navigate to in order to interact with the device.
      </p>

      <section>
        <h3><dfn>WebUSB Platform Capability Descriptor</dfn></h3>
        <p>
          Communication with a device starts with the UA finding the following
          <a>Platform Descriptor</a> in the device's <a>Binary Object Store</a>:
        </p>

        <table>
          <tr>
            <th>Offset</th>
            <th>Field</th>
            <th>Size</th>
            <th>Value</th>
            <th>Description</th>
          </tr>
          <tr>
            <td>0</td>
            <td>bLength</td>
            <td>1</td>
            <td>Number</td>
            <td>Size of this descriptor. Must be set to 23.</td>
          </tr>
          <tr>
            <td>1</td>
            <td>bDescriptorType</td>
            <td>1</td>
            <td>Constant</td>
            <td>DEVICE CAPABILITY descriptor type ([[USB31]] Table 9-6).</td>
          </tr>
          <tr>
            <td>2</td>
            <td>bDevCapabilityType</td>
            <td>1</td>
            <td>Constant</td>
            <td>PLATFORM capability type ([[USB31]] Table 9-14).</td>
          </tr>
          <tr>
            <td>3</td>
            <td>bReserved</td>
            <td>1</td>
            <td>Number</td>
            <td>This field is reserved and shall be set to zero.</td>
          </tr>
          <tr>
            <td>4</td>
            <td>PlatformCapabilityUUID</td>
            <td>16</td>
            <td>UUID</td>
            <td>Must be set to {3408b638-09a9-47a0-8bfd-a0768815b665}.</td>
          </tr>
          <tr>
            <td>20</td>
            <td>bcdVersion</td>
            <td>2</td>
            <td>BCD</td>
            <td>Protocol version supported. Must be set to 0x0100.</td>
          </tr>
          <tr>
            <td>22</td>
            <td>bVendorCode</td>
            <td>1</td>
            <td>Number</td>
            <td>bRequest value used for issuing WebUSB requests.</td>
          </tr>
        </table>
      </section>

      <section>
        <h3>WebUSB Device Requests</h3>
        <p>
          All control transfers defined by this specification are considered to
          be vendor-specific requests. The <code>bVendorCode</code> value found
          in the <a>WebUSB Platform Capability Descriptor</a> provides the UA
          with the <code>bRequest</code> the device expects the host to use when
          issuing control transfers these requests. The request type is then
          specified in the <code>wIndex</code> field.
        </p>

        <table>
          <caption>WebUSB Request Codes</caption>
          <tr>
            <th>Constant</th>
            <th>Value</th>
          </tr>
          <tr>
            <td>GET_ALLOWED_ORIGINS</td>
            <td>1</td>
          </tr>
          <tr>
            <td>GET_LANDING_PAGE</td>
            <td>2</td>
          </tr>
        </table>

        <section>
          <h4>Get Allowed Origins</h4>
          <p>
            This request gets the set of origins allowed to access the device.
            The device MUST return a <a>Descriptor Set Header</a> containing one
            or more <a title="URL descriptor">URL Descriptors</a> possibly
            contained within a combination of
            <a title="configuration subset header">Configuration Subset
            Headers</a> and <a title="function subset header">Function Subset
            Headers</a> which limit their scope to particular portions of the
            device.
          </p>

          <p>
            The URLs returned by this request MUST be interpreted as origins (as
            defined by [[RFC6454]]) and so content beyond the scheme/host/port
            triple MAY be ignored.
          </p>

          <table>
            <tr>
              <th>bmRequestType</td>
              <th>bRequest</th>
              <th>wValue</th>
              <th>wIndex</th>
              <th>wLength</th>
              <th>Data</th>
            </tr>
            <tr>
              <td>11000000B</td>
              <td><code>bVendorCode</code></td>
              <td>Zero</td>
              <td>GET_ALLOWED_ORIGINS</td>
              <td>Descriptor Length</td>
              <td>Descriptor</td>
            </tr>
          </table>
        </section>

        <section>
          <h4>Get Landing Page</h4>
          <p>
            This request gets the landing page to which the UA can be navigated
            in order to interact with the device. While a device may be
            accessible by multiple origins it MUST only have a single landing
            page or none at all.
          </p>

          <p>
            The data returned MUST be a single <a>URL Descriptor</a>.
          </p>

          <table>
            <tr>
              <th>bmRequestType</td>
              <th>bRequest</th>
              <th>wValue</th>
              <th>wIndex</th>
              <th>wLength</th>
              <th>Data</th>
            </tr>
            <tr>
              <td>11000000B</td>
              <td><code>bVendorCode</code></td>
              <td>Zero</td>
              <td>GET_LANDING_PAGE</td>
              <td>Descriptor Length</td>
              <td>Descriptor</td>
            </tr>
          </table>
        </section>
      </section>

      <section>
        <h3>WebUSB Descriptors</h3>
        <p>
          These descriptor types are returned by requests defined in this
          specification.
        </p>

        <table>
          <caption>WebUSB Descriptor Types</caption>
          <tr>
            <th>Constant</th>
            <th>Value</th>
          </tr>
          <tr>
            <td>WEBUSB_DESCRIPTOR_SET_HEADER</td>
            <td>0</td>
          </tr>
          <tr>
            <td>WEBUSB_CONFIGURATION_SUBSET_HEADER</td>
            <td>1</td>
          </tr>
          <tr>
            <td>WEBUSB_FUNCTION_SUBSET_HEADER</td>
            <td>2</td>
          </tr>
          <tr>
            <td>WEBUSB_URL</td>
            <td>3</td>
          </tr>
        </table>

        <section>
          <h4><dfn>Descriptor Set Header</dfn></h4>
          <p>
            A response referring to multiple origins MUST begin with this header
            to identify the total length of the data to follow.
          </p>

          <table>
            <tr>
              <th>Offset</th>
              <th>Field</th>
              <th>Size</th>
              <th>Value</th>
              <th>Description</th>
            </tr>
            <tr>
              <td>0</td>
              <td>bLength</td>
              <td>1</td>
              <td>Number</td>
              <td>Size of this descriptor. Must be set to 4.</td>
            </tr>
            <tr>
              <td>1</td>
              <td>bDescriptorType</td>
              <td>1</td>
              <td>Constant</td>
              <td>WEBUSB_DESCRIPTOR_SET_HEADER.</td>
            </tr>
            <tr>
              <td>2</td>
              <td>wTotalLength</td>
              <td>2</td>
              <td>Number</td>
              <td>Total size of this and all following descriptors.</td>
            </tr>
          </table>
        </section>

        <section>
          <h4><dfn>Configuration Subset Header</dfn></h4>
          <p>
            This header declares that the descriptors following it (up to
            <code>wTotalLength</code> bytes) are scoped to the USB device
            configuration described by the <a>configuration descriptor</a>
            with the given  <code>bConfigurationValue</code>.
          </p>
          <p>
            This descriptor MUST be contained within a <a>Descriptor Set
            Header</a>.
          </p>
          <table>
            <tr>
              <th>Offset</th>
              <th>Field</th>
              <th>Size</th>
              <th>Value</th>
              <th>Description</th>
            </tr>
            <tr>
              <td>0</td>
              <td>bLength</td>
              <td>1</td>
              <td>Number</td>
              <td>Size of this descriptor. Must be set to 4.</td>
            </tr>
            <tr>
              <td>1</td>
              <td>bDescriptorType</td>
              <td>1</td>
              <td>Constant</td>
              <td>WEBUSB_CONFIGURATION_SUBSET_HEADER.</td>
            </tr>
            <tr>
              <td>2</td>
              <td>bConfigurationValue</td>
              <td>1</td>
              <td>Number</td>
              <td>Configuration to which this section applies.</td>
            </tr>
            <tr>
              <td>3</td>
              <td>wTotalLength</td>
              <td>2</td>
              <td>Number</td>
              <td>
                Total size of this and the following descriptors to which this
                header applies.
              </td>
            </tr>
          </table>
        </section>

        <section>
          <h4><dfn>Function Subset Header</dfn></h4>
          <p>
            This header declares that the descriptors following it (up to
            <code>wTotalLength</code> bytes) are scoped to the USB device
            configuration described by the <a>configuration descriptor</a>
            with the given  <code>bConfigurationValue</code>.
          </p>
          <p>
            This descriptor MUST be contained within a <a>Descriptor Set
            Header</a>.
          </p>

          <table>
            <caption>WebUSB Function Subset Header</caption>
            <tr>
              <th>Offset</th>
              <th>Field</th>
              <th>Size</th>
              <th>Value</th>
              <th>Description</th>
            </tr>
            <tr>
              <td>0</td>
              <td>bLength</td>
              <td>1</td>
              <td>Number</td>
              <td>Size of this descriptor. Must be set to 4.</td>
            </tr>
            <tr>
              <td>1</td>
              <td>bDescriptorType</td>
              <td>1</td>
              <td>Constant</td>
              <td>WEBUSB_FUNCTION_SUBSET_HEADER.</td>
            </tr>
            <tr>
              <td>2</td>
              <td>bFirstInterfaceNumber</td>
              <td>1</td>
              <td>Number</td>
              <td>
                First interface of the function to which this section applies.
              </td>
            </tr>
            <tr>
              <td>3</td>
              <td>wTotalLength</td>
              <td>2</td>
              <td>Number</td>
              <td>
                Total size of this and the following descriptors to which this
                header applies.
              </td>
            </tr>
          </table>
        </section>

        <section>
          <h4><dfn>URL Descriptor</dfn></h4>
          <p>
            This descriptor contains a single URL. It may be contained within a
            <a>Descriptor Set Header</a> to apply to the entire device, a
            <a>Configuration Subset Header</a> to apply to a specific
            configuration, or a <a>Function Subset Header</a> to apply to the
            set of interfaces comprising that function.
          </p>

          <table>
            <tr>
              <th>Offset</th>
              <th>Field</th>
              <th>Size</th>
              <th>Value</th>
              <th>Description</th>
            </tr>
            <tr>
              <td>0</td>
              <td>bLength</td>
              <td>1</td>
              <td>Number</td>
              <td>Size of this descriptor.</td>
            </tr>
            <tr>
              <td>1</td>
              <td>bDescriptorType</td>
              <td>1</td>
              <td>Constant</td>
              <td>WEBUSB_URL.</td>
            </tr>
            <tr>
              <td>2</td>
              <td>URL</td>
              <td>Variable</td>
              <td>String</td>
              <td>UTF-8 encoded URL.</td>
            </tr>
          </table>
        </section>
      </section>

      <section>
        <h3>Public Device Registry</h3>
        <p>
          The <a>WebUSB Platform Capability Descriptor</a> and descriptors
          returned by the requests defined above can be elided by publishing
          this information in a public registry of supported USB devices. This
          will allow device manufacturers to support WebUSB on existing devices.
        </p>
      </section>
    </section>

    <section>
      <h2>Device Enumeration</h2>
      <pre class="idl">
        dictionary USBDeviceFilter {
          unsigned short vendorId;
          unsigned short productId;
          octet classCode;
          octet subclassCode;
          octet protocolCode;
        };

        dictionary USBDeviceRequestOptions {
          required sequence&lt;USBDeviceFilter> filters;
        };

        [NoInterfaceObject]
        interface USB {
          Promise&lt;sequence&lt;USBDevice>> getDevices();
          Promise&lt;USBDevice> requestDevice(USBDeviceRequestOptions options);
        };

        partial interface Navigator {
          readonly attribute USB usb;
        };
      </pre>
      <p dfn-for="USBDeviceFilter">
        The <code><dfn>vendorId</dfn></code> and
        <code><dfn>productId</dfn></code> field will cause the filter to match
        any device with the given vendor and (optionally) product identifiers.
      </p>
      <p dfn-for="USBDeviceFilter">
        The <code><dfn>classCode</dfn></code>,
        <code><dfn>subclassCode</dfn></code> and
        <code><dfn>protocolCode</dfn></code> fields will cause the filter to
        match any device that implements the given class, class and subclass, or
        class, subclass and protocol tuple and any composite device with an
        interface implementing the same. A subclass MUST NOT be specified unless
        a class is provided and a protocol MUST NOT be specified unless a
        subclass is also provided.
      </p>
      <p>
        The UA MUST maintain an <dfn>allowed devices set</dfn> for each origin.
        Once a device is added to this set it SHALL remain in the set for a
        period of time determined by the UA's ability to identify the device.
      </p>
      <ul>
        <li>
          For a device with a unique identifier such as a serial number or
          container ID the device SHALL remain in the <a>allowed devices set</a>
          until explicitly removed by the user. Vendor and product IDs MUST NOT
          be considered uniquely identifying.
        </li>
        <li>
          For a device without a unique identifier the device SHALL remain in
          the <a>allowed devices set</a> until it becomes uncertain whether the
          device connected to the host is still the device originally added to
          the set. This MAY happen when the device is disconnected from the
          host, when the UA exits or, if tracked by the host operating system,
          when the host is shut down.
        </li>
      </ul>
      <p dfn-for="USB">
        The <code><dfn>getDevices</dfn>()</code> method, when
        invoked, MUST return a new promise and run the following steps in
        parallel:
      </p>
      <ol>
        <li>
          If the incumbent settings object is not a secure context, reject
          <var>promise</var> with a <code>SecurityError</code> and abort these
          steps.
        </li>
        <li>Let <var>devices</var> be a new array.</li>
        <li>
          For each <var>device</var> in the origin's <a>allowed devices set</a>
          get the <a>USBDevice</a> object representing <var>device</var>, and
          add the result to <var>devices</var>.
        </li>
        <li>
          Resolve <var>promise</var> with <var>devices</var>.
      </ol>
      <p dfn-for="USB">
        The <code><dfn>requestDevice</dfn>(<var>options</var>)</code> method,
        when invoked, MUST return a new promise <var>promise</var> and run the
        following steps in parallel:
      </p>
      <ol>
        <li>
          If the incumbent settings object is not a secure context, reject
          <var>promise</var> with a <code>SecurityError</code> and abort these
          steps.
        </li>
        <li>
          If the algorithm is not allowed to show a popup, reject
          <var>promise</var> with a <code>SecurityError</code> and abort these
          steps.
        </li>
        <li>
          Enumerate all devices which individually match at least one of the
          filters in <code><var>options</var>.filters</code>.
          <p>
            The UA SHOULD apply additional origin-based filtering of available
            devices by consulting an authoritative list of device-origin
            mappings or referring to the origin list specified in the device's
            <a>Binary Object Store</a>.
          </p>
          <p>
            The UA MAY provide additional mechanisms for blacklisting or
            whitelisting specific devices for arbitrary origins.
          </p>
          <p>Let <var>enumerationResult</var> be this result.</p>
        </li>
        <li>
          Even if <var>enumerationResult</var> is empty, display a prompt to the
          user requesting that the user select a device from it. The UA SHOULD
          show a human-readable name of each device.
        </li>
        <li>
          Wait for the user to have selected a <var>device</var> or cancelled
          the prompt.
        </li>
        <li>
          If the user cancels the prompt, reject <var>promise</var> with a
          <code>NotFoundError</code> and abort these steps.
        </li>
        <li>
          Add <var>device</var> to the origin's <a>allowed devices set</a>.
        </li>
        <li>
          Get the <a>USBDevice</a> object representing <var>device</var> and
          resolve <var>promise</var> with that object.
        </li>
      </ol>
    </section>

    <section>
      <h2>Device Usage</h2>
      <pre class="idl">
        interface USBDevice {
          readonly attribute DOMString guid;
          readonly attribute octet usbVersionMajor;
          readonly attribute octet usbVersionMinor;
          readonly attribute octet usbVersionSubminor;
          readonly attribute octet deviceClass;
          readonly attribute octet deviceSubclass;
          readonly attribute octet deviceProtocol;
          readonly attribute unsigned short vendorId;
          readonly attribute unsigned short productId;
          readonly attribute octet deviceVersionMajor;
          readonly attribute octet deviceVersionMinor;
          readonly attribute octet deviceVersionSubminor;
          readonly attribute DOMString? manufacturerName;
          readonly attribute DOMString? productName;
          readonly attribute DOMString? serialNumber;
          readonly attribute FrozenArray&lt;USBConfiguration> configurations;
          Promise&lt;void> open();
          Promise&lt;void> close();
          Promise&lt;void> setConfiguration(octet configurationValue);
          Promise&lt;void> claimInterface(octet interfaceNumber);
          Promise&lt;void> releaseInterface(octet interfaceNumber);
          Promise&lt;void> setInterface(octet interfaceNumber, octet alternateSetting);
          Promise&lt;USBInTransferResult> controlTransferIn(USBControlTransferParameters setup, unsigned short length);
          Promise&lt;USBOutTransferResult> controlTransferOut(USBControlTransferParameters setup, optional BufferSource data);
          Promise&lt;void> clearHalt(octet endpointNumber);
          Promise&lt;USBInTransferResult> transferIn(octet endpointNumber, unsigned long length);
          Promise&lt;USBOutTransferResult> transferOut(octet endpointNumber, BufferSource data);
          Promise&lt;void> reset();
        };
      </pre>
      <p dfn-for="USBDevice">
        The <code><dfn>guid</dfn></code> attribute indicates a unique identifier
        string for the device. This identifier SHALL remain consistent for the
        lifetime of a device's connection to the USB host.
      </p>
      <p dfn-for="USBDevice">

        The <code><dfn>usbVersionMajor</dfn></code>,
        <code><dfn>usbVersionMinor</dfn></code> and
        <code><dfn>usbVersionSubminor</dfn></code> attributes declare the USB
        protocol version supported by the device. They SHALL correspond to the
        value of the <code>bcdUSB</code> field of the <a>device descriptor</a>
        such that a value of <code>0xJJMN</code> has major version
        <code>JJ</code>, minor version <code>M</code> and subminor version
        <code>N</code>.

      </p>
      <p dfn-for="USBDevice">
        The <code><dfn>deviceClass</dfn></code>,
        <code><dfn>deviceSubclass</dfn></code> and
        <code><dfn>deviceProtocol</dfn></code> attributes declare the
        communication interface supported by the device. They MUST correspond
        respectively to the values of the <code>bDeviceClass</code>,
        <code>bDeviceSubClass</code> and <code>bDeviceProtocol</code> fields of
        the <a>device descriptor</a>.
      </p>
      <p dfn-for="USBDevice">
        The <code><dfn>vendorId</dfn></code> and
        <code><dfn>productId</dfn></code> attribute declares the vendor ID
        of the device manufacturer and product ID assigned by the device
        manufacturer. They SHALL correspond to the values of the
        <code>idVendor</code> and <code>idProduct</code> fields of the <a>device
        descriptor</a>.
      </p>
      <p dfn-for="USBDevice">
        The <code><dfn>deviceVersionMajor</dfn></code>,
        <code><dfn>deviceVersionMinor</dfn></code> and
        <code><dfn>deviceVersionSubminor</dfn></code> attributes declare the
        device release number as defined by the device manufacturer. It SHALL
        correspond to the value of the <code>bcdDevice</code> field of the
        <a>device descriptor</a> such that a value of <code>0xJJMN</code> has
        major version <code>JJ</code>, minor version <code>M</code> and subminor
        version <code>N</code>.
      </p>
      <p dfn-for="USBDevice">
        The <code><dfn>configurations</dfn></code> attribute contains a list of
        configurations supported by the device. These configurations SHALL be
        populated from the configuration descriptors reported by the device and
        the number of elements in this list SHALL match the value of the
        <code>bNumConfigurations</code> field of the <a>device descriptor</a>.
      </p>
      <p dfn-for="USBDevice">
        The <code><dfn>manufacturerName</dfn></code>,
        <code><dfn>productName</dfn></code> and
        <code><dfn>serialNumber</dfn></code> attributes SHOULD contain the
        values of the string descriptors referenced by the
        <code>iManufacturer</code>, <code>iProduct</code> and
        <code>iSerialNumber</code> fields of the <a>device descriptor</a> if
        each is available.
      </p>
      <p dfn-for="USBDevice">
        The <code><dfn>open</dfn>()</code> method prepares the device to handle
        further requests for the API. A device MUST be opened before any
        subsequent operations may be performed on it or any of its interfaces.
      </p>
      <p dfn-for="USBDevice">
        The <code><dfn>close</dfn>()</code> method closes an opened device,
        releasing any claimed interfaces.
      </p>
      <p dfn-for="USBDevice">
        The
        <code><dfn>setConfiguration</dfn>(<var>configurationValue</var>)</code>
        method issues an appropriate <code>SET_CONFIGURATION</code> control
        request to set <code><var>configurationValue</var></code> as the
        device's current configuration. The operating system MAY automatically
        select configuration <code>1</code> when the device is enumerated. The
        device MUST be opened before this method is called.
      </p>
      <p dfn-for="USBDevice">
        The <code><dfn>claimInterface</dfn>(<var>interfaceNumber</var>)</code>
        method requests that control over
        <code><var>interfaceNumber</var></code> be granted to the UA. The device
        MUST be opened before this method is called.
      </p>
      <p dfn-for="USBDevice">
        The <code><dfn>releaseInterface</dfn>(<var>interfaceNumber</var>)</code>
        method releases the UA's control over the interface which MUST have been
        previously claimed.
      </p>
      <p dfn-for="USBDevice">
        The <code><dfn>setInterface</dfn>(<var>interfaceNumber</var>,
        <var>alternateSetting</var>)</code> method issues a
        <code>SET_INTERFACE</code> request to activate the endpoints associated
        with <code><var>alternateSetting</var></code> on
        <code><var>interfaceNumber</var></code>. By default the endpoints on
        alternate setting <code>0</code> are selected when the device is
        enumerated or <code><a title="USBDevice.setConfiguration">
        setConfiguration</a>(<var>configurationValue</var>)</code> is
        called and so it isn't necessary to call
        <code><a title="USBDevice.setInterface">
        setInterface</a>(<var>interfaceNumber</var>, 0)</code> before using
        these endpoints. The specified interface MUST be claimed before this
        method can be called.
      </p>
      <p dfn-for="USBDevice">
        The <code><dfn>controlTransferIn</dfn>(<var>setup</var>,
        <var>length</var>)</code> method issues a control transfer to the device
        through its default endpoint. If non-zero,
        <code><var>length</var></code> bytes of data will be read from the
        device during the <a>data stage</a> of the transaction. If
        <code><var>setup.recipient</var></code> is <code>"interface"</code> or
        <code>"endpoint"</code> then the target interface MUST be claimed before
        this method is called.
      </p>
      <p dfn-for="USBDevice">
        The <code><dfn>controlTransferOut</dfn>(<var>setup</var>,
        <var>data</var>)</code> method issues a control transfer to the device
        through its default endpoint. If provided, the contents of the
        <code><var>data</var></code> buffer will be sent to the device during
        the <a>data stage</a> of the transaction. The <code>wLength</code> field
        of the <a>setup packet</a> will be populated with the length of this
        buffer. If <code><var>setup.recipient</var></code> is
        <code>"interface"</code> or <code>"endpoint"</code> then the target
        interface MUST be claimed before this method is called.
      </p>
      <p dfn-for="USBDevice">
        The <code><dfn>clearHalt</dfn>(<var>endpointNumber</var>)</code> method
        clears a stall condition on <code><var>endpointNumber</var></code> by
        issuing the appropriate <code>CLEAR_FEATURE</code> control transfer. The
        interface containing this endpoint MUST be claimed before this method is
        called.
      </p>
      <p dfn-for="USBDevice">
        The <code><dfn>transferIn</dfn>(<var>endpointNumber</var>,
        <var>length</var>)</code> method enqueues a bulk or interrupt IN
        transfer request for <code><var>length</var></code> bytes of data to
        <code><var>endpointNumber</var></code>. The promise returned will be
        resolved with <a>USBInTransferResult</a> containing the data returned by
        the device. The interface containing this endpoint MUST be claimed
        before this method is called.
      </p>
      <p dfn-for="USBDevice">
        The <code><dfn>transferOut</dfn>(<var>endpointNumber</var>,
        <var>data</var>)</code> method enqueues a bulk or interrupt OUT transfer
        to transmit <code><var>data</var></code> to
        <code><var>endpointNumber</var></code>. The promise returned will be
        resolved when the data transfer is complete with a
        <a>USBOutTransferResult</a> indicating the amount of data that was
        successfully sent to the device. The interface containing this endpoint
        MUST be claimed before this method is called.
      </p>
      <p dfn-for="USBDevice">
        The <code><dfn>reset</dfn>()</code> method performs a soft reset on the
        device. The device MUST be opened before this method is called.
      </p>

      <section>
        <h3>Transfers</h3>
        <pre class="idl">
          enum USBRequestType {
            "standard",
            "class",
            "vendor"
          };

          enum USBRecipient {
            "device",
            "interface",
            "endpoint",
            "other"
          };

          enum USBTransferStatus {
            "ok",
            "stall",
            "babble"
          };

          dictionary USBControlTransferParameters {
            required USBRequestType requestType;
            required USBRecipient recipient;
            required octet request;
            required unsigned short value;
            required unsigned short index;
          };

          interface USBInTransferResult {
            readonly attribute ArrayBuffer data;
            readonly attribute USBTransferStatus status;
          };

          interface USBOutTransferResult {
            readonly attribute unsigned long bytesWritten;
            readonly attribute USBTransferStatus status;
          };
        </pre>

        <p>
          A control transfer is a special class of USB traffic most commonly
          used for configuring a device. It consists of three stages: setup,
          data and status. In the <dfn>setup stage</dfn> a  <dfn>setup
          packet</dfn> is transmitted to the device containing request
          parameters including the transfer direction and size of the data to
          follow. In the <dfn>data stage</dfn> that data is either sent to or
          received from the device. In the <dfn>status stage</dfn> successful
          handling of the request is acknowledged or a failure is signaled.
        </p>
        <p dfn-for="USBControlTransferParameters">
          The <code><dfn>requestType</dfn></code> attribute populates part of
          the <code>bmRequestType</code> field of the <a>setup packet</a> to
          indicate whether this request is part of the USB standard, a
          particular USB device class specification or a vendor-specific
          protocol.
        </p>
        <p dfn-for="USBControlTransferParameters">
          The <code><dfn>recipient</dfn></code> attribute populates part of the
          <code>bmRequestType</code> field of the <a>setup packet</a> to
          indicate whether the control transfer is addressed to the entire
          device, or a specific interface or endpoint.
        </p>
        <p dfn-for="USBControlTransferParameters">
          The <code><dfn>request</dfn></code> attribute populates the
          <code>bRequest</code> field of the <a>setup packet</a>. Valid requests
          are defined by the USB standard, USB device class specifications or
          the device vendor.
        </p>
        <p dfn-for="USBControlTransferParameters">
          The <code><dfn>value</dfn></code> and <code><dfn>index</dfn></code>
          attributes populate the <code>wValue</code> and <code>wIndex</code>
          fields of the <a>setup packet</a> respectively. The meaning of these
          fields depends on the request being made.
        </p>
        <p dfn-for="USBInTransferResult">
          A transfer initiated by <code><a title="USBDevice.transferIn">
          transferIn</a>(<var>endpointNumber</var>, <var>length</var>)</code> or
          <code><a title="USBDevice.controlTransferIn">
          controlTransferOut</a>(<var>setup</var>, <var>length</var>)</code> may
          receive up to <code><var>length</var></code> bytes of data which SHALL
          be stored in <code><dfn>data</dfn></code>.
          <code><dfn>status</dfn></code> SHALL have one of the following values
          indicating the final disposition of the transfer:

          <dl>
            <dt><code>"ok"</code></dt>
            <dd>the transfer completed with no errors.</dt>

            <dt><code>"stall"</code></dt>
            <dd>
              the device stalled the pipe. If this is not a control transfer
              <code><a title="USBDevice.clearHalt">clearHalt</a>(
              <var>endpointNumber</var>)</code> must be called to clear the
              failure.
            </dd>
          </dl>
        </p>
        <p dfn-for="USBOutTransferResult">
          A transfer initiated by <code><a title="USBDevice.transferOut">
          transferOut</a>(<var>endpointNumber</var>, <var>data</var>)</code> or
          <code><a title="USBDevice.controlTransferOut">
          controlTransferOut</a>(<var>setup</var>, <var>data</var>)</code> may
          send up to <code><var>data.length</var></code> bytes of data. The
          actual number of bytes transferred SHALL be stored in
          <code><dfn>bytesWritten</dfn></code>. <code><dfn>status</dfn></code>
          SHALL have any of the values above or one of the following to indicate
          the final disposition of the transfer:

          <dl>
            <dt><code>"babble"</code></dt>
            <dd>
              the device attempted to send more data than allowed by the maximum
              packet size specified for the endpoint.
            </dd>
          </dl>
        </p>
      </section>

      <section>
        <h3>Configurations</h3>
        <pre class="idl">
          [Constructor(USBDevice device, octet configurationValue)]
          interface USBConfiguration {
            readonly attribute octet configurationValue;
            readonly attribute DOMString? configurationName;
            readonly attribute FrozenArray&lt;USBInterface> interfaces;
          };
        </pre>
        <p dfn-for="USBConfiguration">
          Each device configuration SHALL have a unique
          <code><dfn>configurationValue</dfn></code> that matches the
          <code>bConfigurationValue</code> fields of the <a>configuration
          descriptor</a> that defines it.
        </p>
        <p dfn-for="USBConfiguration">
          The <code><dfn>configurationName</dfn></code> attribute SHOULD contain
          the value of the string descriptor referenced by the
          <code>iConfiguration</code> field of the <a>configuration
          descriptor</a>, if available.
        </p>
        <p dfn-for="USBConfiguration">
          The <code><dfn>interfaces</dfn></code> attribute SHALL contain a list of
          interfaces exposed by this device configuration. These interfaces SHALL
          by populated from the <a title="interface descriptor">interface
          descriptors</a> contained within this <a>configuration descriptor</a>.
        </p>
        <p class="issue">
          Include some non-normative information about device configurations
        </p>
      </section>

      <section>
        <h3>Interfaces</h2>
        <pre class="idl">
          [Constructor(USBConfiguration configuration, octet interfaceNumber)]
          interface USBInterface {
            readonly attribute octet interfaceNumber;
            readonly attribute FrozenArray&lt;USBAlternateInterface> alternates;
          };

          [Constructor(USBInterface deviceInterface, octet alternateSetting)]
          interface USBAlternateInterface {
            readonly attribute octet alternateSetting;
            readonly attribute octet interfaceClass;
            readonly attribute octet interfaceSubclass;
            readonly attribute octet interfaceProtocol;
            readonly attribute DOMString? interfaceName;
            readonly attribute FrozenArray&lt;USBEndpoint> endpoints;
          };
        </pre>
        <p dfn-for="USBInterface">
          Each interface provides a collection of
          <code><dfn>alternates</dfn></code> identified by a single
          <code>bInterfaceNumber</code> field found in their
          <a title="interface descriptor">interface descriptors</a>. The
          <code><dfn>interfaceNumber</dfn></code> attribute MUST match this field.
        </p>
        <p dfn-for="USBAlternateInterface">
          Each alternative interface configuration SHALL have a unique
          <code><dfn>alternateSetting</dfn></code> within a given interface that
          matches the <code>bAlternateSetting</code> field of the <a>interface
          descriptor</a> that defines it.
        </p>
        <p dfn-for="USBAlternateInterface">
          The <code><dfn>interfaceClass</dfn></code>,
          <code><dfn>interfaceSubclass</dfn></code> and
          <code><dfn>interfaceProtocol</dfn></code> attributes declare the
          communication interface supported by the interface. They MUST correspond
          respectively to the values of the <code>bInterfaceClass</code>,
          <code>bInterfaceSubClass</code> and <code>bInterfaceProtocol</code>
          fields of the <a>interface descriptor</a>.
        </p>
        <p dfn-for="USBAlternateInterface">
          The <code><dfn>interfaceName</dfn></code> attribute SHOULD contain the
          value of the string descriptor referenced by the
          <code>iInterface</code> field of the <a>interface descriptor</a>, if
          available.
        </p>
        <p dfn-for="USBAlternateInterface">
          The <code><dfn>endpoints</dfn></code> attribute SHALL contain a list of
          endpoints exposed by this interface. These endpoints SHALL by populated
          from the endpoint descriptors contained within this <a>interface
          descriptor</a> and the number of elements in this sequence SHALL match
          the value of the <code>bNumEndpoints</code> field of the <a>interface
          descriptor</a>.
        </p>
      </section>

      <section>
        <h3>Endpoints</h2>
        <pre class="idl">
          enum USBDirection {
            "in",
            "out"
          };

          enum USBEndpointType {
            "bulk",
            "interrupt",
            "isochronous"
          };

          [Constructor(USBAlternateInterface alternate, octet endpointNumber, USBDirection direction)]
          interface USBEndpoint {
            readonly attribute octet endpointNumber;
            readonly attribute USBDirection direction;
            readonly attribute USBEndpointType type;
            readonly attribute unsigned long packetSize;
          };
        </pre>
        <p dfn-for="USBEndpoint">
          Each endpoint within a particular device configuration SHALL have a
          unique combination of <code>endpointNumber</code> and
          <code>direction</code>. The <code><dfn>endpointNumber</dfn></code>
          MUST equal the 4 least significant bits of the
          <code>bEndpointAddress</code> field of the <a>endpoint descriptor</a>
          defining the endpoint.
        </p>
        <p dfn-for="USBEndpoint">
          The <code><dfn>direction</dfn></code> attribute declares the transfer
          direction supported by this endpoint and is equal to <code>"in"</code>
          if the most significant bit of the <code>bEndpointAddress</code> is
          set and <code>"out"</code> otherwise. An endpoint may either carry
          data <code>IN</code> from the device to host or <code>OUT</code> from
          host to device.
        </p>
        <p dfn-for="USBEndpoint">
          The <code><dfn>type</dfn></code> attribute declares the type of data
          transfer supported by this endpoint.
        </p>
        <p dfn-for="USBEndpoint">
          The <code><dfn>packetSize</dfn></code> attribute declares the packet
          size employed by this endpoint and MUST be equal to the value of the
          <code>wMaxPacketSize</code> of the <a>endpoint descriptor</a> defining
          it. In a High-Speed, High-Bandwidth endpoint this value will include the
          multiplication factor provided by issuing multiple transactions per
          microframe. In a SuperSpeed device this value will include the
          multiplication factor provided by the <code>bMaxBurst</code> field of
          the SuperSpeed Endpoint Companion descriptor.
        </p>
      </section>
    </section>

    <section>
      <h2>Terminology</h2>
      <p>
        This specification uses several terms taken from [[USB31]]. While
        reference is made to version 3.1 of the Universal Serial Bus many of
        these concepts exist in previous versions as well. Significant
        differences between USB versions that have barring on this specification
        will be called out explicitly.
      </p>
      <p>
        <dfn>Descriptors</dfn> are binary data structures that can be read from
        a device and describe its properties and function:
        <ul>
          <li>
            The <dfn>device descriptor</dfn> contains information applicable to
            the entire devices and is described in section 9.6.1 of [[USB31]].
          </li>
          <li>
            A <dfn>configuration descriptor</dfn> describes a particular set of
            device interfaces and endpoints that can be selected by the host.
            Its fields are described in section 9.6.3 of [[USB31]].
          </li>
          <li>
            An <dfn>interface descriptor</dfn> describes the interface of a
            particular functional component of a device including its protocol
            and communication endpoints. Its fields are described in section
            9.6.5 of [[USB31]].
          </li>
          <li>
            An <dfn>endpoint descriptor</dfn> describes a channel through which
            data is either sent to or received from the device. Its fields are
            described in section 9.6.6 of [[USB31]].
          </li>
        </ul>
      </p>
      <p>
        The <dfn>Binary Object Store</dfn>
        (<abbr title="Binary Object Store">BOS</abbr>) is an additional set of
        descriptors that are more free-form than the standard device
        descriptors. Of note is the <dfn>Platform Descriptor</dfn> type which
        allows third parties (such as this specification) to declare their own
        types of descriptors. Each of these is identified by a UUID. The Binary
        Object Store is described in section 9.6.2 of [[USB31]].
      </p>
    </section>
  </body>
</html>
